# 全局异常处理

Spring Boot 提供了强大而灵活的异常处理机制，帮助开发者统一、优雅地处理应用程序中抛出的异常。以下是 Spring Boot 异常处理的详细说明，包括常用注解、全局异常处理器、自定义异常、最佳实践等。

## 异常处理的核心注解

### 1. `@ControllerAdvice`

- 用于定义**全局异常处理器**。
- 可以捕获所有被 `@Controller` 或 `@RestController` 注解的类中抛出的异常。
- 通常与 `@ExceptionHandler` 配合使用。

### 2. `@ExceptionHandler`

- 用于处理特定类型的异常。
- 可以写在 Controller 内部（局部处理），也可以写在 `@ControllerAdvice` 类中（全局处理）。

### 3. `@ResponseStatus`

- 用于指定当某个异常被抛出时，返回的 HTTP 状态码。
- 可以直接标注在自定义异常类上。

------

## 全局异常处理示例

```
@RestControllerAdvice
public class GlobalExceptionHandler {

    // 处理自定义业务异常
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
        ErrorResponse error = new ErrorResponse("BUSINESS_ERROR", ex.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
    }

    // 处理参数校验异常（如 @Valid 失败）
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        String message = ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .collect(Collectors.joining(", "));
        ErrorResponse error = new ErrorResponse("VALIDATION_ERROR", message);
        return ResponseEntity.badRequest().body(error);
    }

    // 处理通用异常（兜底）
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ErrorResponse error = new ErrorResponse("INTERNAL_ERROR", "服务器内部错误");
        // 生产环境中不要暴露具体异常信息
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(error);
    }
}
```

其中 `ErrorResponse` 是一个通用的错误响应体：

```
public class ErrorResponse {
    private String code;
    private String message;

    public ErrorResponse(String code, String message) {
        this.code = code;
        this.message = message;
    }

    // getter/setter...
}
```

------

## 自定义异常类

```
@ResponseStatus(HttpStatus.BAD_REQUEST)
public class BusinessException extends RuntimeException {
    public BusinessException(String message) {
        super(message);
    }
}
```

这样，只要抛出 `BusinessException`，Spring Boot 会自动返回 400 状态码（如果未被 `@ExceptionHandler` 捕获）。

------

## 局部异常处理（Controller 内）



```
@RestController
public class UserController {

    @GetMapping("/user/{id}")
    public User getUser(@PathVariable Long id) {
        if (id <= 0) {
            throw new IllegalArgumentException("ID 必须大于 0");
        }
        return userService.findById(id);
    }

    // 仅对当前 Controller 生效
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<String> handleIllegalArgumentException(IllegalArgumentException ex) {
        return ResponseEntity.badRequest().body("参数错误: " + ex.getMessage());
    }
}
```

> 注意：局部异常处理优先级高于全局异常处理。

------

## 常见异常类型及处理建议

| 异常类型                                    | 说明                         | 建议处理方式                           |
| :------------------------------------------ | :--------------------------- | :------------------------------------- |
| `MethodArgumentNotValidException`           | `@Valid` 校验失败            | 返回字段校验错误信息                   |
| `BindException`                             | 表单绑定错误（非 JSON 请求） | 类似 `MethodArgumentNotValidException` |
| `HttpMessageNotReadableException`           | JSON 解析失败                | 返回“请求格式错误”                     |
| `ResourceNotFoundException`（自定义）       | 资源不存在                   | 返回 404                               |
| `AccessDeniedException`                     | 权限不足                     | 返回 403                               |
| `NullPointerException` / `RuntimeException` | 未预期异常                   | 全局兜底，记录日志，返回 500           |

------

## 最佳实践

1. **统一错误响应格式**
   定义标准的 `ErrorResponse` 结构，便于前端处理。

2. **不要暴露敏感信息**
   生产环境中避免将异常堆栈或数据库信息返回给客户端。

3. 记录日志

   在全局异常处理器中记录异常日志，便于排查问题：

   java

   

   ```
   @ExceptionHandler(Exception.class)
   public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
       log.error("Unexpected error occurred", ex); // 记录完整堆栈
       return ResponseEntity.status(500).body(new ErrorResponse("SERVER_ERROR", "系统繁忙，请稍后再试"));
   }
   ```

4. 区分客户端错误与服务端错误

   

   - 4xx：客户端问题（参数错误、权限不足等）
   - 5xx：服务端问题（数据库连接失败、空指针等）

5. **结合 Validation 使用**
   利用 `javax.validation` 或 `jakarta.validation` 进行参数校验，减少手动判断。

------

## 扩展：错误页面（适用于 Thymeleaf 等模板引擎）

如果你使用的是服务端渲染（非纯 API），可以通过 `ErrorController` 自定义错误页面：

```
@Controller
public class CustomErrorController implements ErrorController {

    @RequestMapping("/error")
    public String handleError(HttpServletRequest request) {
        Integer statusCode = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);
        if (statusCode != null) {
            if (statusCode == 404) {
                return "error/404";
            } else if (statusCode == 500) {
                return "error/500";
            }
        }
        return "error/general";
    }
}
```

> 注意：Spring Boot 2.3+ 默认不再注册 `BasicErrorController`，除非你引入 `spring-boot-starter-web` 并启用错误页面支持。

