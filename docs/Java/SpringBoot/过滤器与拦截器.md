# 过滤器与拦截器

## Filter

Spring Boot 中的 **Filter（过滤器）** 是基于 Java Servlet 规范的核心组件之一，用于在请求到达目标资源（如 Controller）之前、或响应返回客户端之后，执行预处理或后处理逻辑。它是实现横切关注点（Cross-cutting Concerns）的重要手段，常用于日志记录、权限校验、跨域处理、性能监控等场景。

### Filter 的核心概念

#### 所属技术栈

- Filter 属于 **Servlet API**（`javax.servlet.Filter` 或 `jakarta.servlet.Filter`），与 Spring 框架无关，但 Spring Boot 提供了便捷的集成方式。
- 它作用于整个 Web 容器层级，**早于 Spring MVC 的 DispatcherServlet** 执行。

#### 核心方法（`Filter` 接口）

```java
public interface Filter {
    void init(FilterConfig filterConfig) throws ServletException;   // 初始化
    void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
        throws IOException, ServletException;                       // 核心处理逻辑
    void destroy();                                                // 销毁资源
}
```

`doFilter`是关键方法：

- 在其中可以读取/修改 `request` 和 `response`
- **必须调用 `chain.doFilter(request, response)`** 才能将请求继续传递下去
- 可以在 `chain.doFilter()` 前后分别实现“前置处理”和“后置处理”

### Spring Boot 中使用 Filter 的三种方式

#### 使用 `@Component` 自动注册（最简单）

```java
@Component
@Order(1) // 控制执行顺序，数值越小优先级越高
public class LoggingFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest req = (HttpServletRequest) request;
        long start = System.currentTimeMillis();
        
        System.out.println("请求开始: " + req.getMethod() + " " + req.getRequestURI());
        
        chain.doFilter(request, response); // 放行
        
        long duration = System.currentTimeMillis() - start;
        System.out.println("请求结束，耗时: " + duration + "ms");
    }
}
```

优点：简单快捷
缺点：

- 默认拦截 **所有路径（`/\*`）**
- 执行顺序需靠 `@Order` 控制，且多个 `@Component` Filter 之间顺序不稳定

#### 使用 `FilterRegistrationBean` 显式注册（推荐用于生产）

```java
@Configuration
public class FilterConfig {

    @Bean
    public FilterRegistrationBean<LoggingFilter> loggingFilter() {
        FilterRegistrationBean<LoggingFilter> bean = new FilterRegistrationBean<>();
        bean.setFilter(new LoggingFilter());
        bean.addUrlPatterns("/api/*");      // 只拦截 /api/ 开头的请求
        bean.setOrder(1);                   // 优先级
        bean.setName("loggingFilter");
        return bean;
    }
}
```

优点：

- 精确控制 URL 匹配路径
- 明确设置执行顺序
- 可配置初始化参数、是否异步支持等

#### 使用 `@WebFilter` + `@ServletComponentScan`（兼容传统 Servlet）

```java
@WebFilter(urlPatterns = "/admin/*", filterName = "authFilter")
public class AuthFilter implements Filter {
    // 实现 doFilter 等方法
}

// 启动类上加注解
@SpringBootApplication
@ServletComponentScan // 启用 @WebFilter、@WebListener 等 Servlet 组件扫描
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

> [!WARNING]
>
> 注意：此方式依赖 Tomcat 内嵌容器，且 `@Order` 不生效，排序按类名字母顺序。

###  Filter 的典型应用场景

| 场景             | 说明                                             |
| ---------------- | ------------------------------------------------ |
| 请求日志记录     | 记录 URI、IP、参数、耗时等                       |
| 身份认证/授权    | 检查 Token、Session 是否有效                     |
| 跨域处理（CORS） | 设置 `Access-Control-Allow-*` 响应头             |
| 字符编码统一     | 强制设置 `request.setCharacterEncoding("UTF-8")` |
| 敏感词过滤       | 修改请求参数或响应内容                           |
| 压缩响应         | 对响应体进行 GZIP 压缩                           |

跨域示例：

```java
@Component
public class CorsFilter implements Filter {
    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) 
            throws IOException, ServletException {
        HttpServletResponse response = (HttpServletResponse) res;
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        response.setHeader("Access-Control-Max-Age", "3600");
        response.setHeader("Access-Control-Allow-Headers", "*");
        chain.doFilter(req, res);
    }
}
```

### Filter 与 Interceptor 的区别

| 特性       | Filter                                  | Interceptor                                           |
| ---------- | --------------------------------------- | ----------------------------------------------------- |
| 所属规范   | Servlet API                             | Spring MVC                                            |
| 作用范围   | 所有 Web 请求（包括静态资源）           | 仅 Spring MVC 的 Controller 请求                      |
| 执行时机   | 在 `DispatcherServlet` 之前             | 在 `DispatcherServlet` 内部                           |
| 可访问对象 | `ServletRequest`, `ServletResponse`     | `HandlerMethod`, `ModelAndView`                       |
| 异常处理   | 无法捕获 Controller 抛出的异常          | `afterCompletion` 可获取异常                          |
| 配置方式   | `@Component` / `FilterRegistrationBean` | 实现 `HandlerInterceptor` + 注册到 `WebMvcConfigurer` |

**建议**：

- 全局通用逻辑（如编码、CORS、安全头） → 用 **Filter**
- 业务相关逻辑（如权限、日志、性能监控） → 用 **Interceptor**

### 注意事项

1. **不要忘记 `chain.doFilter()`**，否则请求会被阻断。
2. 多个 Filter 的执行顺序：
   - `FilterRegistrationBean` 注册的优先级 **高于** `@Component` 注册的
   - 同类型中通过 `setOrder()` 或 `@Order` 控制（值越小越先执行）
3. Filter 中不能直接注入 Request Scope 的 Bean（如 `@RequestScope`），因为 Filter 生命周期早于 Spring 的请求上下文。
4. 若需确保每个请求只执行一次 Filter（尤其在转发/包含时），可继承 `OncePerRequestFilter`：

```JAVA
@Component
public class OncePerRequestLogFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
        // 你的逻辑
        chain.doFilter(request, response);
    }
}
```

## Interceptor

在 Spring Boot 中，**Interceptor（拦截器）** 是 Spring MVC 提供的一种强大机制，用于在请求到达 Controller 之前、之后或整个请求完成后执行自定义逻辑。它属于 **Spring 容器管理的组件**，可以使用依赖注入（DI）、访问 Spring Bean，并专注于处理 **由 DispatcherServlet 路由的请求**（即 Spring MVC 的请求）。

### 核心概念

### 拦截器接口：`HandlerInterceptor`

Spring 提供了 `org.springframework.web.servlet.HandlerInterceptor` 接口，包含三个核心方法：

```java
public interface HandlerInterceptor {
    // 请求处理前调用（Controller 方法执行前）
    boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) 
        throws Exception;

    // 请求处理后调用（Controller 方法执行后，视图渲染前）
    void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, 
                    ModelAndView modelAndView) throws Exception;

    // 整个请求完成后调用（视图渲染后，即使发生异常也会执行）
    void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, 
                         Exception ex) throws Exception;
}
```

| 方法              | 执行时机                      | 返回值/作用                                          |
| ----------------- | ----------------------------- | ---------------------------------------------------- |
| `preHandle`       | Controller 执行前             | 返回 `true` 放行，`false` 中断请求（常用于权限校验） |
| `postHandle`      | Controller 执行后，视图渲染前 | 可修改 `ModelAndView`（如添加公共数据）              |
| `afterCompletion` | 视图渲染完成或异常抛出后      | 用于资源清理、日志记录（类似 `finally`）             |

### 实现步骤

#### 创建自定义拦截器类

```java
@Component
public class AuthInterceptor implements HandlerInterceptor {

    @Autowired
    private TokenService tokenService; // 可注入 Spring Bean

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) 
            throws Exception {
        String token = request.getHeader("Authorization");
        
        if (token == null || !tokenService.isValid(token)) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            response.getWriter().write("Unauthorized");
            return false; // 拦截请求
        }
        
        // 将用户信息存入 request，供 Controller 使用
        User user = tokenService.parseUser(token);
        request.setAttribute("currentUser", user);
        return true; // 放行
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, 
                                Object handler, Exception ex) throws Exception {
        // 清理 ThreadLocal 或记录日志
        System.out.println("请求完成，用户: " + request.getAttribute("currentUser"));
    }
}
```

#### 注册拦截器并配置路径

创建配置类，实现 `WebMvcConfigurer` 接口：

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Autowired
    private AuthInterceptor authInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(authInterceptor)
                .addPathPatterns("/api/**")          // 拦截所有 /api 开头的请求
                .excludePathPatterns(                 // 排除以下路径
                    "/api/login",
                    "/api/register",
                    "/api/public/**"
                );
    }
}
```

**路径匹配规则**：

- `/**`：匹配所有路径
- `/admin/*`：匹配一级路径（如 `/admin/user`，但不匹配 `/admin/user/profile`）
- `/admin/**`：匹配多级路径（如 `/admin/user/profile`）
- 支持 Ant 风格通配符：`?`（单字符）、`*`（单层）、`**`（多层）

#### 多拦截器顺序控制

注册顺序决定 `preHandle` 执行顺序，而 `postHandle` 和 `afterCompletion` 则 **逆序执行**（栈结构）：

```
@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(loggingInterceptor).order(1); // 先执行
    registry.addInterceptor(authInterceptor).order(2);    // 后执行
}
```

执行流程示例：

```
preHandle: Logging → Auth
Controller 执行
postHandle: Auth → Logging
afterCompletion: Auth → Logging
```



### 典型应用场景

**身份认证与权限校验**

- 检查 Token、Session 是否有效
- 验证用户角色是否具备访问权限

**请求日志与性能监控**

```
public class PerformanceInterceptor implements HandlerInterceptor {
    private final ThreadLocal<Long> startTime = new ThreadLocal<>();

    @Override
    public boolean preHandle(HttpServletRequest req, HttpServletResponse res, Object handler) {
        startTime.set(System.currentTimeMillis());
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest req, HttpServletResponse res, 
                                Object handler, Exception ex) {
        long duration = System.currentTimeMillis() - startTime.get();
        startTime.remove(); // 防止内存泄漏
        log.info("URI: {} 耗时: {}ms", req.getRequestURI(), duration);
    }
}
```

**参数预处理**

- 统一分页参数（如默认 `pageSize=10`）
- 时间格式标准化

**响应统一包装**

- 在 `postHandle` 中向 `ModelAndView` 添加公共字段（如时间戳、版本号）

**防重复提交**

- 利用 Redis 记录请求指纹（如 `userId + uri + timestamp`），防止重复操作

### Interceptor vs Filter 对比

| 特性           | Interceptor（拦截器）                        | Filter（过滤器）                              |
| -------------- | -------------------------------------------- | --------------------------------------------- |
| 所属框架       | Spring MVC                                   | Servlet 规范                                  |
| 作用范围       | 仅 Spring MVC 路由的请求（如 `@Controller`） | 所有 Web 请求（包括静态资源、错误页等）       |
| 依赖容器       | 必须运行在 Spring 上下文中                   | 独立于 Spring，由 Servlet 容器管理            |
| 可注入 Bean    | ✅ 支持 `@Autowired`                          | ❌ 默认不支持（需手动获取 ApplicationContext） |
| 可访问 Handler | ✅ 可获取 `HandlerMethod`、方法注解等         | ❌ 无法获取 Controller 信息                    |
| 异常处理       | `afterCompletion` 可捕获异常                 | 无法捕获 Controller 抛出的异常                |
| 典型用途       | 业务逻辑相关（权限、日志、参数处理）         | 通用底层处理（编码、CORS、安全头）            |

### 高级技巧与注意事项

#### 获取 Controller 方法信息

在 `preHandle` 中判断是否为 `HandlerMethod`，可获取方法签名、注解等：

```java
if (handler instanceof HandlerMethod) {
    HandlerMethod method = (HandlerMethod) handler;
    Method targetMethod = method.getMethod();
    // 检查方法是否有 @IgnoreAuth 注解
    if (targetMethod.isAnnotationPresent(IgnoreAuth.class)) {
        return true; // 跳过认证
    }
}
```

####  避免拦截静态资源

通常排除 `/static/**`、`/favicon.ico`、`/error` 等路径：

```
excludePathPatterns("/static/**", "/error", "/webjars/**")
```

#### 线程安全

- 拦截器是单例（Singleton），**不要使用实例变量存储请求数据**
- 使用 `ThreadLocal` 或 `request.setAttribute()` 传递上下文

#### 异常处理

- `afterCompletion` 的 `ex` 参数可获取 Controller 抛出的异常
- 适合记录错误日志，但**不能修改响应内容**（此时响应已提交）