# 核心特性

## 自动配置（Auto-Configuration）

Spring Boot 自动配置是其最重要的特性之一，它通过"约定大于配置"的理念极大地简化了Spring应用的开发。下面我将详细解析自动配置的工作原理和机制。

Spring Boot 自动配置会尝试根据添加的依赖项自动配置的 Spring 应用程序。例如：

- 引入 `spring-boot-starter-web` 会自动配置 Spring MVC、内嵌 Tomcat。
- 引入 `spring-boot-starter-data-jpa` 会自动配置数据源、Hibernate、EntityManager。 

### 核心原理

spring boot 默认只能扫描自己主程序所在的包及其下面的子包，能扫描到`spring-boot-autoconfigure`中的配置是通过 `@EnableAutoConfiguration` 注解导入的，他是spring boot 自动配置的核心。

#### @EnableAutoConfiguration 注解

`@SpringBootApplication` 注解包含三个核心注解，其中 `@EnableAutoConfiguration` 是开启自动配置的关键：

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration  // 这是关键注解
@ComponentScan(excludeFilters = { /* ... */ })
public @interface SpringBootApplication {
    // ...
}
```

#### 加载机制

Spring Boot 启动时会通过 `SpringFactoriesLoader` 加载 `META-INF/spring.factories` 文件中注册的自动配置类（sping boot v2.7之前）

Spring Boot 启动时会通过 `SpringFactoriesLoader` 加载 ``META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`` 文件中注册的自动配置类（sping boot v2.7引入， v3.0以上默认）

`@Import({AutoConfigurationImportSelector.class})`注解将容器中的配置批量导入

按需导入：每一个配置类，都有条件注解，只有条件生效时才会导入

### 条件化配置

自动配置的核心在于条件化配置，Spring Boot 提供了丰富的 `@Conditional` 派生注解：

| 注解                              | 功能描述                       |
| :-------------------------------- | :----------------------------- |
| `@ConditionalOnClass`             | 类路径下存在指定的类时生效     |
| `@ConditionalOnMissingClass`      | 类路径下不存在指定的类时生效   |
| `@ConditionalOnBean`              | 容器中存在指定Bean时生效       |
| `@ConditionalOnMissingBean`       | 容器中不存在指定Bean时生效     |
| `@ConditionalOnProperty`          | 指定的属性有特定值时生效       |
| `@ConditionalOnResource`          | 类路径下存在指定资源文件时生效 |
| `@ConditionalOnWebApplication`    | 当前是Web应用时生效            |
| `@ConditionalOnNotWebApplication` | 当前不是Web应用时生效          |
| `@ConditionalOnExpression`        | 满足SpEL表达式时生效           |

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({DataSource.class, EmbeddedDatabaseType.class})
@ConditionalOnMissingBean(type = "io.r2dbc.spi.ConnectionFactory")
@EnableConfigurationProperties(DataSourceProperties.class)
@Import({DataSourcePoolMetadataProvidersConfiguration.class, 
         DataSourceInitializationConfiguration.class})
public class DataSourceAutoConfiguration {

    @Configuration(proxyBeanMethods = false)
    @Conditional(EmbeddedDatabaseCondition.class)
    @ConditionalOnMissingBean({DataSource.class, XADataSource.class})
    @Import(EmbeddedDataSourceConfiguration.class)
    public static class EmbeddedDatabaseConfiguration {
    }

    @Configuration(proxyBeanMethods = false)
    @Conditional(PooledDataSourceCondition.class)
    @ConditionalOnMissingBean({DataSource.class, XADataSource.class})
    @Import({DataSourceConfiguration.Hikari.class, 
             DataSourceConfiguration.Tomcat.class,
             DataSourceConfiguration.Dbcp2.class, 
             DataSourceConfiguration.Generic.class})
    public static class PooledDataSourceConfiguration {
    }
    // ...
}
```

### 自动配置类属性绑定

自动配置类通常与属性配置绑定：

```java
@ConfigurationProperties(prefix = "spring.datasource")
public class DataSourceProperties implements BeanClassLoaderAware, InitializingBean {
    private String driverClassName;
    private String url;
    private String username;
    private String password;
    // 其他属性和方法...
}
```

在 `application.properties` 中配置：

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=secret
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
```

### 实现流程

1. **启动应用**：Spring Boot 应用启动
2. **加载配置**：读取 `META-INF/spring.factories` 中的自动配置类
3. **条件检查**：对每个自动配置类执行条件注解检查
4. **注册Bean**：满足条件的配置类中的Bean被注册到容器中
5. **属性绑定**：将配置文件中的属性值绑定到相应的Bean上

### 查看自动配置情况

**使用调试模式**

在 `application.properties` 中添加：

```properties
debug=true
```

启动时会显示自动配置报告，包括：

- 已启用的自动配置（Positive matches）
- 未启用的自动配置（Negative matches）
- 排除的自动配置（Exclusions）

**使用Actuator端点**

添加Spring Boot Actuator依赖后，访问 `/actuator/conditions` 端点：

```json
{
  "contexts": {
    "application": {
      "positiveMatches": {
        "DataSourceAutoConfiguration": [
          {
            "condition": "OnClassCondition",
            "message": "@ConditionalOnClass classes found: javax.sql.DataSource,org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType"
          }
        ]
      },
      "negativeMatches": {
        "RabbitAutoConfiguration": [
          {
            "condition": "OnClassCondition",
            "message": "@ConditionalOnClass did not find required class 'com.rabbitmq.client.Channel'"
          }
        ]
      }
    }
  }
}
```



### 逐步取消自动配置

自动配置是非侵入式的。可以随时定义自己的配置来替换自动配置的某些部分。例如，您添加了自己的[`DataSource`](https://docs.oracle.com/en/java/javase/17/docs/api/java.sql/javax/sql/DataSource.html)Bean，则默认的嵌入式数据库支持将会取消。

### 配置默认值

配置文件中的所有配置项都是和某个类的对象值进行绑定的，绑定了配置文件中每一项的类叫做属性类，如ServerProperties 绑定了所有 tomcat 服务器相关的配置，MultipartProperities 绑定了所有文件上传相关的配置。

可在 [Spring Boot 官方文档](https://docs.spring.io/spring-boot/appendix/application-properties/index.html)查看所有默认配置。

### 禁用特定的配置类

禁用特定的自动配置类是一种常见的需求，尤其是在需要自定义配置、解决配置冲突或优化应用性能时。

**@SpringBootApplication**

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;

@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
// 排除多个
@SpringBootApplication(exclude = {
    DataSourceAutoConfiguration.class,
    SecurityAutoConfiguration.class
})
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

- `@SpringBootApplication` 注解默认包含 `@EnableAutoConfiguration`。
- 使用 `exclude` 属性可以排除一个或多个自动配置类。
- **适用场景**：开发阶段或需要在代码中明确排除自动配置的情况。

 **@EnableAutoConfiguration**

```
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.Configuration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;

@Configuration
@EnableAutoConfiguration(exclude = {DataSourceAutoConfiguration.class})
public class MyConfiguration {
    // 自定义配置
}
```

- 适用于没有使用 `@SpringBootApplication` 的项目。
- 可以结合 `@ComponentScan` 使用。

**通过配置文件排除**

```
#application.properties
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
```

或：

```
#application.yml
spring:
  autoconfigure:
    exclude:
      - org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration
```

### 自动配置包

自动配置包是指各种自动配置功能在扫描实体和 Spring Da 存储库等内容时默认查找的包。[`@EnableAutoConfiguration`](https://docs.spring.io/spring-boot/3.5.4/api/java/org/springframework/boot/autoconfigure/EnableAutoConfiguration.html)注解（直接指定或通过其在 上的存在[`@SpringBootApplication`](https://docs.spring.io/spring-boot/3.5.4/api/java/org/springframework/boot/autoconfigure/SpringBootApplication.html)）决定了默认的自动配置包。可以使用注解配置其他包[`@AutoConfigurationPackage`](https://docs.spring.io/spring-boot/3.5.4/api/java/org/springframework/boot/autoconfigure/AutoConfigurationPackage.html)。



## 依赖管理（Starter Dependencies）

- **依赖聚合**：将相关功能的依赖打包成“Starter”，简化依赖管理。
- **版本兼容性**：由 `spring-boot-dependencies` 统一管理依赖版本，避免冲突。

常见 Starter 分类：

| 类型     | 示例                           | 功能                                    |
| -------- | ------------------------------ | --------------------------------------- |
| 核心     | `spring-boot-starter`          | 核心依赖（Spring Core、Spring Context） |
| Web      | `spring-boot-starter-web`      | Spring MVC、Tomcat、JSON 支持           |
| 数据访问 | `spring-boot-starter-data-jpa` | Hibernate、JPA、数据库连接池            |
| 消息队列 | `spring-boot-starter-amqp`     | RabbitMQ 客户端                         |
| 测试     | `spring-boot-starter-test`     | JUnit、Mockito、Spring Test 集成        |

```xml
<!-- Maven 配置示例 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

## 内嵌服务器（Embedded Server）

- **开箱即用**：无需外部部署 Tomcat、Jetty 等容器，直接打包为可执行 JAR/WAR。
- 支持多种容器：
  - 默认使用 Tomcat，但可替换为 Jetty、Undertow。
  - 响应式应用支持 Reactor Netty（如 Spring WebFlux）。

```
// 主类直接运行即可启动内嵌服务器
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

------

##  约定优于配置（Convention Over Configuration）

- 默认规则：通过约定减少配置项，例如：
  - 静态资源默认路径：`src/main/resources/static`。
  - 主配置文件默认名：`application.properties` 或 `application.yml`。
- **灵活覆盖**：可通过自定义配置覆盖默认规则（如修改端口 `server.port=8081`）。

```
# application.yml 配置示例
server:
  port: 8081
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: secret
```

------

## 生产就绪（Production Ready）

- **健康检查**：通过 `/actuator/health` 监控应用状态。
- **指标监控**：提供 `/actuator/metrics` 收集 JVM、HTTP 请求等指标。
- **外部化配置**：支持从命令行参数、环境变量、配置文件动态调整配置。

| 端点                    | 用途                   |
| ----------------------- | ---------------------- |
| `/actuator/health`      | 健康检查               |
| `/actuator/metrics`     | 性能指标               |
| `/actuator/configprops` | 配置属性               |
| `/actuator/shutdown`    | 安全关闭应用（需启用） |

```
<!-- 启用 Actuator -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

------

## 快速启动与部署

- **可执行 JAR**：通过 Maven/Gradle 插件打包为单一 JAR，直接运行 `java -jar app.jar`。
- **无代码生成**：无需 XML 配置或代码生成，纯 Java 注解驱动。

```java
<!-- Maven 打包配置 -->
<build>
    <plugins>
        <plugin>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-maven-plugin</artifactId>
        </plugin>
    </plugins>
</build>
```

------

## 多环境配置

- **Profile 配置**：通过 `application-{profile}.yml` 管理不同环境（如开发、测试、生产）。
- **动态切换**：通过 `spring.profiles.active` 指定当前环境。

```
# application-dev.yml
server:
  port: 8080

# application-prod.yml
server:
  port: 80
```

```
# 启动时指定环境
java -jar app.jar --spring.profiles.active=prod
```

------

## 响应式编程支持

- **WebFlux 框架**：支持非阻塞 I/O 和响应式流（Reactive Streams），适用于高并发场景。
- **R2DBC**：响应式数据库连接，替代传统的 JDBC。

```
@RestController
public class ReactiveController {
    @GetMapping("/flux")
    public Flux<String> fluxExample() {
        return Flux.just("Hello", "Spring Boot");
    }
}
```



## 控制反转与依赖注入

### 核心概念

**控制反转（IoC）**

- **定义**：控制反转是一种设计原则，将对象的创建和依赖管理的控制权从程序代码中移交给外部容器（如 Spring）。
- **核心思想**：程序本身不再主动创建对象或管理依赖，而是由容器负责对象的生命周期和依赖关系。
- **作用**：降低代码耦合度，提高可扩展性和可维护性。

**依赖注入（DI）**

- **定义**：依赖注入是实现控制反转的具体技术，通过容器将对象所需的依赖（如其他对象、配置参数）自动注入到目标对象中。
- 实现方式：
  - **构造器注入**：通过构造函数传递依赖。
  - **Setter 方法注入**：通过 Setter 方法设置依赖。
  - **字段注入**：通过注解直接注入依赖（如 `@Autowired`）

### 传统方式与 IoC/DI 的对比

**传统方式的问题**

- **紧耦合**：对象主动创建依赖，导致类与类之间高度耦合。
- **维护困难**：修改依赖关系需要修改源码。
- **难以测试**：依赖对象无法灵活替换为 Mock 对象。

```java
// 传统方式：紧耦合示例
public class UserService {
    private UserRepository userRepository = new UserRepository(); // 手动创建依赖
}
```

**IoC/DI 的优势**

- **松耦合**：依赖由容器注入，对象无需关心依赖的具体实现。
- **可扩展性**：替换依赖实现无需修改代码。
- **可测试性**：依赖可灵活替换为测试用的 Mock 对象。

```java
// IoC/DI 示例：通过构造器注入
public class UserService {
    private UserRepository userRepository;

    public UserService(UserRepository userRepository) { // 依赖由外部注入
        this.userRepository = userRepository;
    }
}
```

### IoC/DI 的实际应用

**解耦业务逻辑**

通过接口抽象依赖，实现松耦合：

```
public interface PaymentService {
    void pay(double amount);
}

@Service
public class CreditCardPayment implements PaymentService {
    public void pay(double amount) { /* 信用卡支付逻辑 */ }
}

@Service
public class OrderService {
    @Autowired
    private PaymentService paymentService; // 依赖接口，而非具体实现
}
```

**动态切换实现**

通过配置或条件注解动态选择依赖实现：

```
@Bean
@ConditionalOnProperty(name = "payment.type", havingValue = "credit")
public PaymentService creditPayment() {
    return new CreditCardPayment();
}

@Bean
@ConditionalOnProperty(name = "payment.type", havingValue = "paypal")
public PaymentService paypalPayment() {
    return new PayPalPayment();
}
```

**单元测试**

通过依赖注入灵活替换依赖为 Mock 对象：

```
@RunWith(MockitoJUnitRunner.class)
public class UserServiceTest {
    @Mock
    private UserRepository userRepository;

    @InjectMocks
    private UserService userService;
}
```

## Bean

在 Spring Boot 中，**Bean 是由 Spring 容器管理的对象**，是 Spring 框架中依赖注入（DI）和控制反转（IoC）的核心实现。Spring Boot 通过自动扫描、自动配置和约定优于配置的原则，简化了 Bean 的定义和管理。

### 定义

- **Bean 是 Spring 容器管理的对象**，通常是一个普通的 Java 类（POJO）。
- Spring 容器负责 Bean 的 **创建、装配、生命周期管理**。
- Bean 之间的依赖关系由 Spring 自动注入，实现松耦合的编程模式。

### 创建方式

#### 注解自动扫描

通过 `@Component`、`@Service`、`@Repository`、`@Controller` 等注解，Spring Boot 会自动扫描并注册 Bean。

```java
@Component
public class MyComponent {
    public void doSomething() {
        System.out.println("Doing something...");
    }
}
```

- `@Component`：通用组件，适用于任何类。
- `@Service`：用于服务层（业务逻辑）。
- `@Repository`：用于数据访问层（DAO），提供异常转换支持。
- `@Controller`：用于控制器层（Web 层），返回视图名称。
- `@RestController`：组合 `@Controller` 和 `@ResponseBody`，适用于 RESTful API。

####  使用 `@Configuration` 和 `@Bean` 注解

通过 Java 配置类显式定义 Bean。

```
@Configuration
public class MyConfig {
    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
```

- `@Configuration`：声明该类是一个配置类。
- `@Bean`：声明一个方法返回的对象由 Spring 管理。

####  使用 XML 配置（不推荐）

虽然 Spring Boot 推荐使用注解配置，但仍然支持 XML 配置。

```
<beans xmlns="http://www.springframework.org/schema/beans">
    <bean id="myBean" class="com.example.MyBean" />
</beans>
```

### Bean 的作用域（Scope）

Bean 的作用域决定了其生命周期和可见性。Spring Boot 支持以下作用域：

| **作用域**            | **描述**                                     | **使用场景**                                   |
| --------------------- | -------------------------------------------- | ---------------------------------------------- |
| **singleton**（默认） | 每个 Spring 容器中只有一个实例               | 默认作用域，适用于无状态的组件。               |
| **prototype**         | 每次请求都会创建一个新的实例                 | 适用于有状态的组件（如每次请求需要独立实例）。 |
| **request**           | 每个 HTTP 请求生命周期内创建一个实例         | 适用于 Web 应用，每个请求独立实例。            |
| **session**           | 每个 HTTP Session 生命周期内创建一个实例     | 适用于需要在会话中保持状态的组件。             |
| **application**       | 每个 `ServletContext` 生命周期内创建一个实例 | 适用于全局共享的数据。                         |
| **websocket**         | 每个 WebSocket 会话生命周期内创建一个实例    | 适用于 WebSocket 应用。                        |

定义作用域：

```java
@Bean
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public MyBean prototypeBean() {
    return new MyBean();
}
```

------

### Bean 的生命周期

Spring 容器管理 Bean 的整个生命周期，包括以下阶段：

1. **实例化（Instantiation）**
    Spring 容器通过无参构造方法或工厂方法创建 Bean 实例。
2. **属性填充（Population）**
    Spring 容器将依赖注入到 Bean 中（如 `@Autowired` 注解）。
3. **初始化（Initialization）**
   - 调用 `@PostConstruct` 注解的方法（在 Bean 使用前执行）。
   - 调用 `InitializingBean` 接口的 `afterPropertiesSet()` 方法。
   - 调用 `@Bean(initMethod = "init")` 指定的初始化方法。
4. **使用（Usage）**
    Bean 被其他组件使用（如注入到其他 Bean 中）。
5. **销毁（Destruction）**
   - 调用 `@PreDestroy` 注解的方法（在 Bean 销毁前执行）。
   - 调用 `DisposableBean` 接口的 `destroy()` 方法。
   - 调用 `@Bean(destroyMethod = "destroy")` 指定的销毁方法。

生命周期方法：

```java
@Component
public class MyBean {
    @PostConstruct
    public void init() {
        System.out.println("Bean 初始化");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("Bean 销毁");
    }
}
```

### 依赖注入

Spring Boot 支持多种依赖注入方式：

#### 字段注入

通过 `@Autowired` 注解直接注入依赖。

```java
@Component
public class MyComponent {
    @Autowired
    private MyService myService;
}
```

#### 构造方法注入

推荐使用构造方法注入依赖，便于单元测试。

```java
@Component
public class MyComponent {
    private final MyService myService;

    public MyComponent(MyService myService) {
        this.myService = myService;
    }
}
```

####  方法注入

```javascript
@Component
public class MyComponent {
    private MyService myService;

    @Autowired
    public void setMyService(MyService myService) {
        this.myService = myService;
    }
}
```

## 配置类



## 属性绑定

### 属性绑定的核心作用

Spring Boot 通过属性绑定机制，将 `application.yml` 或 `application.properties` 中的配置项映射到 Java 对象或字段中，实现 **类型安全** 和 **集中管理配置** 的目标。

### `@value` 注解

`@Value` 是 Spring 提供的注解，用于将 **配置文件中的属性值** 注入到 **Spring 管理的 Bean** 中。它适用于 **单个属性注入**，尤其适合简单配置项（如字符串、布尔值、数字等）。

#### 基本用法

**注入简单属性**

```
// application.properties
home.location= location
home.post= 8080
home.user=admin
```

```java
@Service
public class HelloService implements com.dazzle.start.service.HelloService {
    @Value("${home.location}")
    private String location;

    @Value("${home.post}")
    private String post;

    @Value("${home.user}")
    private String user;

    public String hello() {
        System.out.println("location" + location);
        System.out.println("post" + post);
        System.out.println("user:" + user);
        return "hello world1";
    }
}
```

**注入默认值**

如果配置文件中未定义属性，可以通过 `:` 设置默认值：

```
@Value("${app.timeout:5000}")
private int timeout;
```

**注入系统环境变量**

`@Value` 也可以读取系统环境变量：

```
@Value("${JAVA_HOME}")
private String javaHome;
```

#### 高级用法

**使用 SpEL 表达式**

`@Value` 支持 **Spring Expression Language (SpEL)**，实现动态值注入。

```
@Value("#{systemProperties['user.name']}")
private String userName;

@Value("#{T(java.util.Arrays).asList('dev', 'test')}")
private List<String> environments;
```

**注入集合类型**

虽然 `@Value` 主要用于简单属性，但也可以通过 SpEL 注入集合：

```
@Value("#{'${app.allowed-ips}'.split(',')}")
private List<String> allowedIps;
```

```
app:
  allowed-ips: 192.168.1.1,192.168.1.2
```

**注入资源文件**

通过 `@Value` 注入资源文件（如 `classpath` 下的文件）：

```
@Value("classpath:config/sample.txt")
private Resource resource;
```

#### 验证属性注入

`@Value` 本身不支持直接验证注入值的合法性，但可以通过以下方式实现验证：

**手动验证**

```
@PostConstruct
public void validateConfig() {
    if (maxRetry < 1) {
        throw new IllegalArgumentException("Max retry must be >= 1");
    }
}
```

**结合 `@Validated` 和 `@Min`/`@NotBlank`**

虽然 `@Value` 不直接支持 JSR 380 注解，但可以将属性绑定到一个被 `@ConfigurationProperties` 和 `@Validated` 注解的类中，再通过 `@Value` 注入该类的字段。

```
@Component
@ConfigurationProperties(prefix = "app")
@Validated
public class AppProperties {

    @Min(value = 1, message = "Max retry must be >= 1")
    private int maxRetry;

    // Getter and Setter
}

// 在其他类中注入 AppProperties
@Autowired
private AppProperties appProperties;
```

#### 多配置文件支持

`@Value` 支持通过 **`application-{profile}.yml`** 或 **环境变量** 动态注入不同值。

```
@Value("${app.apiUrl}")
private String apiUrl;
```

**配置文件（`application-dev.yml`）：**

```
app:
  apiUrl: http://localhost:8080
```

**配置文件（`application-prod.yml`）：**

```
app:
  apiUrl: https://api.example.com
```

**切换环境：**

```
spring:
  profiles:
    active: prod
```

### `@ConfigurationProperties`注解

`@ConfigurationProperties` 是 Spring Boot 提供的注解，用于将 **配置文件中的属性** 映射到 **Java 对象** 中，实现 **类型安全** 和 **集中管理复杂配置** 的目标。相比 `@Value`，它更适合处理 **嵌套结构、集合、Map** 等复杂配置。

#### 基本用法

**配置文件（`application.yml`）：**

```yml
app:
  api-url: "https://api.example.com"
  max-retry: 3
  enable-feature: true
```

或（application.properties）：

```
app.api-url= "https://api.example.com"
app.max-retry= 3
app.enable-feature= true
```

**定义配置类**

使用 `@ConfigurationProperties` 注解一个类，并通过 `prefix` 指定配置前缀。

```java
@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {

    private String apiUrl;
    private int maxRetry;
    private boolean enableFeature;

    // Getters and Setters
    public String getApiUrl() { return apiUrl; }
    public void setApiUrl(String apiUrl) { this.apiUrl = apiUrl; }

    public int getMaxRetry() { return maxRetry; }
    public void setMaxRetry(int maxRetry) { this.maxRetry = maxRetry; }

    public boolean isEnableFeature() { return enableFeature; }
    public void setEnableFeature(boolean enableFeature) { this.enableFeature = enableFeature; }
}
```

**使用配置类**

```java
@Service
public class HelloService implements com.dazzle.start.service.HelloService {

    private final AppProperties appProperties;

    HelloService(AppProperties appProperties) {
        this.appProperties = appProperties;
    }

    public String hello() {
        System.out.println(this.appProperties.getApiUrl());
        System.out.println(this.appProperties.getMaxRetry());
        System.out.println(this.appProperties.getEnableFeature());
        return "hello world1";
    }
}
```

**标注在方法上**

当 `@ConfigurationProperties` 标注在方法上时，它的作用是：

- **将配置文件中的属性绑定到该方法返回的对象实例上**。
- 通常与 `@Bean` 一起使用，用于定义某个 Bean 的属性配置。

```
@Configuration
public class AppConfig {

    @Bean
    @ConfigurationProperties("app.datasource")
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }
}
```

#### **高级用法**

##### 嵌套对象绑定

将属性映射到嵌套对象中。

```java
@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {

    private DatabaseConfig database;
    private FeatureConfig feature;

    // Getters and Setters
}

public class DatabaseConfig {
    private String url;
    private String username;
    private String password;

    // Getters and Setters
}

public class FeatureConfig {
    private boolean enableNew;
    private int timeout;

    // Getters and Setters
}
```

**配置文件（`application.yml`）：**

```yml
app:
  database:
    url: jdbc:mysql://localhost:3306/mydb
    username: root
    password: 123456
  feature:
    enable-new: true
    timeout: 5000
```

**配置类使用**

```java
@Service
public class HelloService implements com.dazzle.start.service.HelloService {

    private final AppProperties appProperties;

    HelloService(AppProperties appProperties) {
        this.appProperties = appProperties;
    }

    public String hello() {
        System.out.println(this.appProperties.getDataBaseConfig().getPassword());
        System.out.println(this.appProperties.getFeatureConfig().getTimeout());
        return "hello world1";
    }
}
```

##### 集合绑定

支持 `List`、`Set`、`Map` 等集合类型。

```
@Component
@ConfigurationProperties(prefix = "app")
public class AppProperties {

    private List<String> allowedIps;
    private Map<String, String> envSettings;

    // Getters and Setters
}
```

**配置文件（`application.yml`）：**

```
app:
  allowed-ips:
    - 192.168.1.1
    - 192.168.1.2
  env-settings:
    dev: localhost
    prod: api.example.com
```

##### 松散绑定（Relaxed Binding）

Spring Boot 支持灵活的属性命名规则，例如：

| **Java 字段名** | **YAML 属性名**  | **Properties 属性名** |
| --------------- | ---------------- | --------------------- |
| `apiUrl`        | `api-url`        | `api.url`             |
| `maxRetry`      | `max-retry`      | `max.retry`           |
| `enableFeature` | `enable-feature` | `enable.feature`      |

#### 属性验证

使用 `@Validated` 和 JSR 380 注解对属性进行验证。

```
@Component
@ConfigurationProperties(prefix = "app")
@Validated
public class AppProperties {

    @NotBlank(message = "API URL 不能为空")
    private String apiUrl;

    @Min(value = 1, message = "最大重试次数必须大于等于 1")
    private int maxRetry;

    // Getters and Setters
}
```

**启用验证：**

```
@EnableConfigurationProperties(AppProperties.class)
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### `EnableConfigurationProperties`注解

#### 核心作用

`@EnableConfigurationProperties` 是 Spring Boot 提供的注解，用于 **启用对 `@ConfigurationProperties` 注解的支持**，确保 Spring 能正确扫描并绑定配置属性到 Java 对象。

**主要功能：**

- **注册配置属性类**：将带有 `@ConfigurationProperties` 注解的类注册为 Spring Bean。
- **启用属性绑定机制**：确保配置文件（如 `application.yml`）中的属性能正确映射到对应的 Java 对象。
- **支持验证机制**：结合 `@Validated` 实现属性值的合法性校验。

#### 使用方式

**标注在配置类上**

这是最常见的用法，用于显式启用配置属性支持。

```java
@EnableConfigurationProperties(AppProperties.class)
@SpringBootApplication
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

**作为 `@Import` 的一部分**

在自定义配置中，可以通过 `@Import` 导入配置属性类：

```
@Configuration
@Import({AppProperties.class})
public class AppConfig {
    // 其他配置
}
```

**显式注册多个配置类**

可以一次注册多个配置属性类：

```
@EnableConfigurationProperties({AppProperties.class, DatabaseProperties.class})
@SpringBootApplication
public class Application {
    // ...
}
```

#### 版本差异

**Spring Boot 2.4 之前**

**必须手动启用**：所有使用 `@ConfigurationProperties` 的类都需要通过 `@EnableConfigurationProperties` 显式注册。

```
@EnableConfigurationProperties(AppProperties.class)
@SpringBootApplication
public class Application { ... }
```

**Spring Boot 2.4 及之后**

- **自动启用**：Spring Boot 会自动扫描并注册所有带有 `@ConfigurationProperties` 注解的类（前提是类在主应用类的包路径下或子包中）。
- **无需手动添加**：大多数情况下不再需要 `@EnableConfigurationProperties`。
- 例外情况：
  - 如果配置类不在主应用类的包路径下，仍需手动注册。
  - 如果需要启用验证（`@Validated`），需手动添加 `@EnableConfigurationProperties`。

#### 与 `@Component` 和 `@Bean` 的区别

| **注解**                                  | **作用**                               | **是否需要 `@EnableConfigurationProperties`** |
| ----------------------------------------- | -------------------------------------- | --------------------------------------------- |
| `@Component` + `@ConfigurationProperties` | 自动注册配置类（Spring Boot 2.4+）     | 否                                            |
| `@Bean` + `@ConfigurationProperties`      | 在 `@Configuration` 类中定义配置 Bean  | 否（但需确保类被扫描到）                      |
| `@EnableConfigurationProperties`          | 显式注册配置类（兼容旧版本或外部模块） | 是（Spring Boot 2.4 之前）                    |

## 完整示例

### 项目结构与依赖管理

首先，创建一个 Maven 父项目管理两个子模块：`greeting-spring-boot-starter`（自动配置模块）和 `demo-application`（测试应用）。

#### 父项目 pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>greeting-spring-boot-project</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <packaging>pom</packaging>
    <modules>
        <module>greeting-spring-boot-starter</module>
        <module>demo-application</module>
    </modules>

    <properties>
        <java.version>17</java.version>
        <spring-boot.version>3.2.0</spring-boot.version> <!-- 使用 Spring Boot 3.x -->
        <maven.compiler.source>17</maven.compiler.source>
        <maven.compiler.target>17</maven.compiler.target>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>${spring-boot.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
</project>
```

### 创建自动配置模块

#### Starter 模块 POM 配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.example</groupId>
        <artifactId>greeting-spring-boot-project</artifactId>
        <version>1.0.0-SNAPSHOT</version>
    </parent>
    
    <artifactId>greeting-spring-boot-starter</artifactId>
    
    <dependencies>
        <!-- Spring Boot 自动配置支持 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
        </dependency>
        <!-- 配置注解处理器，用于生成配置元数据 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>
        <!-- 可选：用于条件注解 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>
```

#### 创建配置属性类

配置属性类允许通过 `application.properties` 或 `application.yml` 自定义行为。

```java
package com.example.greeting.config;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "greeting") // 配置前缀为 greeting
public class GreetingProperties {

    private String defaultName = "World"; // 默认值
    private String messagePrefix = "Hello";
    private String messageSuffix = "!";
    private boolean enabled = true;

    // Getter 和 Setter 方法
    public String getDefaultName() {
        return defaultName;
    }

    public void setDefaultName(String defaultName) {
        this.defaultName = defaultName;
    }

    public String getMessagePrefix() {
        return messagePrefix;
    }

    public void setMessagePrefix(String messagePrefix) {
        this.messagePrefix = messagePrefix;
    }

    public String getMessageSuffix() {
        return messageSuffix;
    }

    public void setMessageSuffix(String messageSuffix) {
        this.messageSuffix = messageSuffix;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
}
```

#### 创建服务组件

这是自动配置将暴露的核心服务功能。

```
package com.example.greeting.service;

public class GreetingService {

    private final String defaultName;
    private final String messagePrefix;
    private final String messageSuffix;

    public GreetingService(String defaultName, String messagePrefix, String messageSuffix) {
        this.defaultName = defaultName;
        this.messagePrefix = messagePrefix;
        this.messageSuffix = messageSuffix;
    }

    public String greet() {
        return greet(defaultName);
    }

    public String greet(String name) {
        return messagePrefix + " " + name + messageSuffix;
    }
}
```

#### 创建自动配置类

自动配置类使用条件注解控制配置何时生效。168

java

```
package com.example.greeting.autoconfigure;

import com.example.greeting.config.GreetingProperties;
import com.example.greeting.service.GreetingService;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration(proxyBeanMethods = false) // 优化配置类性能
@ConditionalOnClass(GreetingService.class) // 类路径下存在 GreetingService 时生效:cite[6]:cite[8]
@EnableConfigurationProperties(GreetingProperties.class) // 启用配置属性绑定:cite[1]:cite[6]
@ConditionalOnProperty(prefix = "greeting", name = "enabled", havingValue = "true", matchIfMissing = true) // 条件控制:cite[8]
public class GreetingAutoConfiguration {

    // 声明 GreetingService Bean，当容器中不存在该类型的 Bean 时才创建:cite[6]:cite[8]
    @Bean
    @ConditionalOnMissingBean
    public GreetingService greetingService(GreetingProperties properties) {
        return new GreetingService(
            properties.getDefaultName(),
            properties.getMessagePrefix(),
            properties.getMessageSuffix()
        );
    }
}
```

#### 注册自动配置（Spring Boot 3.0+ 方式）

在 `src/main/resources` 目录下创建文件：
`META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports`

文件内容（一行一个自动配置类）：

```
com.example.greeting.autoconfigure.GreetingAutoConfiguration
```

### 创建测试应用

#### 测试应用 POM 配置

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.example</groupId>
        <artifactId>greeting-spring-boot-project</artifactId>
        <version>1.0.0-SNAPSHOT</version>
    </parent>
    
    <artifactId>demo-application</artifactId>
    
    <dependencies>
        <!-- Spring Boot Web 支持 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <!-- 引入自定义 starter -->
        <dependency>
            <groupId>com.example</groupId>
            <artifactId>greeting-spring-boot-starter</artifactId>
            <version>${project.version}</version>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

#### 创建应用主类

```
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

#### 创建测试控制器

```java
package com.example.demo.controller;

import com.example.greeting.service.GreetingService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class GreetingController {

    private final GreetingService greetingService;

    // 通过构造函数注入 GreetingService
    public GreetingController(GreetingService greetingService) {
        this.greetingService = greetingService;
    }

    @GetMapping("/greet")
    public String greet() {
        return greetingService.greet();
    }

    @GetMapping("/greet")
    public String greetWithName(@RequestParam String name) {
        return greetingService.greet(name);
    }
}
```

#### 配置应用属性

在 `src/main/resources/application.yml` 中：

```yml

# Greeting 配置:cite[1]
greeting:
  default-name: "Spring Boot 3"
  message-prefix: "Hi"
  message-suffix: "!!!" 
  enabled: true # 可设置为 false 来禁用自动配置

# 服务器配置
server:
  port: 8080
```
