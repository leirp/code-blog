# 数据类型

Java 是一种强类型语言，这意味着每个变量和表达式在编译时都必须有明确的类型,，在内存中分配不同大小的内存空间。Java 的数据类型可以分为两大类：**基本数据类型（Primitive Data Types）** 和 **引用数据类型（Reference Data Types）**。

------

##  基本数据类型（Primitive Data Types）

基本数据类型是 Java 中最基础的数据类型，它们直接存储值，而不是对象的引用。Java 有 8 种基本数据类型，分为以下四类：

### 数字类型

| 数据类型 | 大小（字节） | 取值范围                                          | 默认值 |
| :------- | :----------- | :------------------------------------------------ | :----- |
| `byte`   | 1            | -128 到 127                                       | 0      |
| `short`  | 2            | -32,768 到 32,767                                 | 0      |
| `int`    | 4            | -2^31 到 2^31-1 (-2,147,483,648 到 2,147,483,647) | 0      |
| `long`   | 8            | -2^63 到 2^63-1                                   | 0L     |

Java 的各个整数类型有固定的范围和字段长度，不受各个操作系统的影响，以保证Java 程序的可移植性。

**示例：**

```java
byte b = 100;
short s = 1000;
int i = 100000;
long l = 10000000000L; // 注意：long 类型需要在数字后加 'L'

// 科学计数法
double a = 5.12e2;  // 5.12*10^2
double b = 5.12e-2; // 5.12*10^-2
float c = 5.12e2f; // 5.12*10^2
float d = 5.12e-2f; // 5.12*10^-2

byte a = 100000L; // 错误
byte c = 128  // 错误
long b = 111;   // 正确
// 强行蒋较大的字节的整数类型转换为较小字节的整数，编译器可能会报错。
```

**浮点数使用陷阱：**

在两个浮点数相除时，可能会出现精度丢失，所以当对是小数的运算结果判断时需要小心。

```java
double a = 8.1/3;  // 2.6999999999999997
// c
if (a == b ) {
	System.out.println("相等");
} else {
	System.out.println("不相等");
}
if (Math.abs(a-b) < 0.000001) {
	System.out.println("相等");
} else {
	System.out.println("不相等");
}
```




------

### 浮点类型

| 数据类型 | 大小（字节） | 取值范围                                   | 默认值 |
| :------- | :----------- | :----------------------------------------- | :----- |
| `float`  | 4            | 单精度浮点数，约 ±3.40282347E+38F          | 0.0f   |
| `double` | 8            | 双精度浮点数，约 ±1.79769313486231570E+308 | 0.0d   |

与整数类型类似，Java 浮点类型也有固定的范围和字段长度，不受具体操作系统的影响。

通常情况下应该使用 `double`，因为他比`float` 更加精准。

**示例：**

```java
float f = 3.14f; // 注意：float 类型需要在数字后加 'f'
double d = 3.141592653589793;

double a = 0.1;  // 正确
double b = 0.2F; // 正确 float 的大小比 double 小，所以 b 的类型会被自动转换成 double
float c = 0.3F; // 正确
float d = 0.4; // 错误  double 的大小要比 float 大，强行转换会导致数据丢失，所以编译器会报错
```

------

### 字符类型

| 数据类型 | 大小（字节） | 取值范围               | 默认值   |
| :------- | :----------- | :--------------------- | :------- |
| `char`   | 2            | 0 到 65,535（Unicode） | '\u0000' |

**示例：**

```java
char c = 'A';
char unicodeChar = '\u0041'; // Unicode 表示，等价于 'A'
```

------

### 布尔类型

| 数据类型  | 大小（字节）    | 取值范围          | 默认值  |
| :-------- | :-------------- | :---------------- | :------ |
| `boolean` | 1（未严格定义） | `true` 或 `false` | `false` |

**示例：**

```java
boolean flag = true;
```

------



## 包装器类型

Java 包装类（Wrapper Classes）是将 **8 种基本数据类型** 封装为对象的类，位于 `java.lang` 包中。每个基本数据类型都有对应的包装类

Java 提供了以下包装器类型，与基本数据类型一一对应：

- Byte（对应 byte）
- Short（对应 short）
- Integer（对应 int）
- Long（对应 long）
- Float（对应 float）
- Double（对应 double）
- Character（对应 char）
- Boolean（对应 boolean）

包装器类型允许我们使用基本数据类型提供的各种实用方法，并兼容需要对象类型的场景。

```java
// 使用 Integer 包装器类型
Integer integerValue = new Integer(42);
System.out.println("整数值: " + integerValue);

// 将字符串转换为整数
String numberString = "123";
int parsedNumber = Integer.parseInt(numberString);
System.out.println("整数值: " + parsedNumber);

// 使用 Character 包装器类型
Character charValue = new Character('A');
System.out.println("字符: " + charValue);

// 检查字符是否为数字
char testChar = '9';
if (Character.isDigit(testChar)) {
System.out.println("字符是个数字.");
}
```



## 引用数据类型（Reference Data Types）

引用数据类型存储的是对象的引用（内存地址），而不是实际的值。Java 中的引用数据类型包括：

### 类（Class）

- 例如：`String`、自定义类等。

- **示例：**

  

  ```
  String str = "Hello, World!";
  ```

### 接口（Interface）

- 接口是一种特殊的引用类型，用于定义方法签名。

- **示例：**

  ```
  List<String> list = new ArrayList<>();
  ```

### 数组（Array）

- 数组是一种固定大小的容器，可以存储相同类型的多个元素。

- **示例：**

  ```
  int[] numbers = {1, 2, 3, 4, 5};
  String[] names = new String[10];
  ```

###  枚举（Enum）

- 枚举是一种特殊的类，用于定义一组常量。

- **示例：**

  ```
  enum Day {
      MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
  }
  Day today = Day.MONDAY;
  ```

------

##  基本数据类型 vs 引用数据类型

| 特性         | 基本数据类型                    | 引用数据类型           |
| :----------- | :------------------------------ | :--------------------- |
| **存储内容** | 实际值                          | 对象的引用（内存地址） |
| **内存分配** | 栈内存                          | 堆内存                 |
| **默认值**   | 有默认值（如 `int` 默认是 `0`） | 默认是 `null`          |
| **性能**     | 访问速度快                      | 访问速度相对较慢       |
| **示例**     | `int a = 10;`                   | `String s = "Hello";`  |

------

##  自动装箱和拆箱（Autoboxing and Unboxing）

Java 提供了自动装箱和拆箱机制，使得基本数据类型和对应的包装类可以自动转换。

- **自动装箱**：将基本数据类型转换为对应的包装类。

  ```
  Integer i = 10; // 自动装箱，等价于 Integer i = Integer.valueOf(10);
  ```

- **自动拆箱**：将包装类转换为对应的基本数据类型。

  ```
  int j = i; // 自动拆箱，等价于 int j = i.intValue();
  ```



## 类型转换

### 自动类型转换

动类型转换（自动类型提升）是 Java 编译器在不需要显式转换的情况下，将一种基本数据类型自动转换为另一种基本数据类型的过程。这种转换通常发生在表达式求值期间，当不同类型的数据需要相互兼容时。自动类型转换遵循以下规则：

- 如果任一操作数是 double 类型，其他操作数将被转换为 double 类型。
- 否则，如果任一操作数是 float 类型，其他操作数将被转换为 float 类型。
- 否则，如果任一操作数是 long 类型，其他操作数将被转换为 long 类型。
- 否则，所有操作数将被转换为 int 类型。

自动类型转换只发生在兼容类型之间。例如，从较小的数据类型（如 int）到较大的数据类型（如 long 或 double）的转换是安全的，因为较大的数据类型可以容纳较小数据类型的所有可能值。

```
byte -> short -> int -> long -> float -> double
char -> int -> long -> float -> double
```

```java
int a = 5;
double b = 2.6 ;
System.out.println(a+b);
```

### 强制类型转换

强制类型转换是 Java 中将一种数据类型显式转换为另一种数据类型的过程。与自动类型转换不同，强制类型转换需要程序员显式地指定要执行的转换。强制类型转换在以下情况中可能需要：

- 将较大的数据类型转换为较小的数据类型。
- 将浮点数转换为整数。
- 将字符类型转换为数值类型。

强制类型转换可能会导致数据丢失或精度降低，因为目标类型可能无法容纳原始类型的所有可能值。因此，在进行强制类型转换时，需要确保转换后的值仍然在目标类型的范围内。

```java
double -> float -> long -> int -> char -> short -> byte
```

```javascript
double doubleValue = 1.8;
int intValue = (int) doubleValue;
System.out.println("整数值: " + intValue); // 输出：整数值: 42
```

## 6. 总结

- **基本数据类型**：直接存储值，性能高，适用于简单的数据存储。
- **引用数据类型**：存储对象的引用，适用于复杂的数据结构和面向对象编程。

根据具体的需求选择合适的数据类型，可以提高代码的效率和可读性。