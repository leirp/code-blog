# 集合框架

Java 集合框架（Java Collections Framework, JCF）是 Java 标准库中用于存储和操作一组对象的核心工具。它通过统一的接口和实现类，解决了数组长度固定、类型单一、操作复杂等问题，提供了高效、灵活的数据结构和算法支持。

## 集合框架的层次结构

Java 集合框架分为两大体系：

`Collection` 接口：存储单个元素的集合，主要子接口包括：

- **`List`**：有序、可重复。
- **`Set`**：无序、不可重复。
- **`Queue`**：先进先出（FIFO）或双端队列（Deque）。

`Map` 接口：存储键值对（Key-Value），核心实现类包括：

- **`HashMap`**、**`TreeMap`**、**`LinkedHashMap`**、**`ConcurrentHashMap`**。

## 核心接口与实现类

### Collection 接口

`Collection` 是 Java 集合框架的 **顶层接口**，位于 `java.util` 包中，用于存储和操作一组对象（元素）。它定义了集合的基本操作，如添加、删除、遍历、查询等。所有单列集合（如 `List`、`Set`、`Queue`）均继承自该接口。

#### 核心特点

- **单列集合**：每个元素独立存储（与 `Map` 的键值对形式不同）。
- **通用操作**：提供统一的方法操作集合元素。
- **子接口**：`List`、`Set`、`Queue` 是其主要子接口。

#### **Collection 接口的核心方法**

以下是 `Collection` 接口的常用方法（基于 JDK 8 及以上版本）：

| 方法名                                          | 功能描述                                 |
| ----------------------------------------------- | ---------------------------------------- |
| **`boolean add(E e)`**                          | 向集合中添加一个元素。                   |
| **`boolean addAll(Collection<? extends E> c)`** | 将另一个集合的所有元素添加到当前集合。   |
| **`void clear()`**                              | 清空集合中的所有元素。                   |
| **`boolean remove(Object o)`**                  | 从集合中删除指定元素（若存在）。         |
| **`boolean removeAll(Collection<?> c)`**        | 删除与指定集合中相同的元素。             |
| **`boolean contains(Object o)`**                | 判断集合是否包含指定元素。               |
| **`boolean containsAll(Collection<?> c)`**      | 判断集合是否包含指定集合的所有元素。     |
| **`boolean isEmpty()`**                         | 判断集合是否为空。                       |
| **`int size()`**                                | 返回集合中的元素数量。                   |
| **`Object[] toArray()`**                        | 将集合转换为对象数组。                   |
| **`<T> T[] toArray(T[] a)`**                    | 将集合转换为指定类型的数组。             |
| **`Iterator<E> iterator()`**                    | 返回集合的迭代器，用于遍历元素。         |
| **`boolean retainAll(Collection<?> c)`**        | 保留与指定集合的交集元素，移除其他元素。 |
| **`Stream<E> stream()`**                        | 返回集合的流式操作对象（JDK 8 新增）。   |

```java
Collection<String> collection = new ArrayList<>();
collection.add("Java");
collection.addAll(Arrays.asList("Python", "C++"));

System.out.println(collection.contains("Java")); // true
System.out.println(collection.size()); // 3

collection.remove("C++");
collection.clear();
System.out.println(collection.isEmpty()); // true
```

### `List` 接口（有序、可重复）

核心实现类：

- **`ArrayList`**：基于动态数组实现，支持快速随机访问（O(1)），增删效率较低（O(n)），适合读多写少的场景。
- **`LinkedList`**：基于双向链表实现，增删效率高（O(1)），随机访问慢（O(n)），适合频繁插入/删除的场景。
- **`Vector`**：线程安全的动态数组（方法加锁），性能较差，已被 `CopyOnWriteArrayList` 或 `Collections.synchronizedList()` 替代。

```java
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
System.out.println(list.get(0)); // 输出 "Java"
```

### `Set` 接口（无序、不可重复）

核心实现类：

- **`HashSet`**：基于哈希表实现，插入、删除、查找时间复杂度为 O(1)，不保证遍历顺序。
- **`LinkedHashSet`**：继承自 `HashSet`，通过双向链表维护插入顺序。
- **`TreeSet`**：基于红黑树实现，元素按自然排序或自定义排序存储（O(log n)）。

```java
Map<String, Integer> map = new HashMap<>();
map.put("Java", 1);
map.put("Python", 2);
System.out.println(map.get("Java")); // 输出 1
```

### **`Map` 接口（键值对存储）**

核心实现类：

- **`HashMap`**：基于哈希表实现，查询效率高（O(1)），非线程安全，允许一个 `null` 键和多个 `null` 值。
- **`LinkedHashMap`**：维护插入顺序或访问顺序，适合实现 LRU 缓存。
- **`TreeMap`**：基于红黑树实现，键按自然排序或自定义排序存储（O(log n)）。
- **`ConcurrentHashMap`**：线程安全的哈希表，采用分段锁技术提升并发性能。

```
Map<String, Integer> map = new HashMap<>();
map.put("Java", 1);
map.put("Python", 2);
System.out.println(map.get("Java")); // 输出 1
```



### `Queue` 接口（队列操作）

**核心实现类**：

- **`LinkedList`**：可作为队列或双端队列使用。
- **`PriorityQueue`**：基于堆结构实现，按优先级排序元素。
- **`ArrayDeque`**：基于动态数组的双端队列，性能优于 `LinkedList`。

```java
Queue<String> queue = new LinkedList<>();
queue.offer("First");
queue.offer("Second");
System.out.println(queue.poll()); // 输出 "First"
```

## List 接口

### `ArrayList`

`ArrayList` 是 Java 集合框架中实现 `List` 接口的动态数组，位于 `java.util` 包中。它继承自 `AbstractList`，并实现了 `List`、`RandomAccess`、`Cloneable` 和 `Serializable` 接口。

#### 核心特性

- **动态数组**：底层基于 `Object[]` 实现，支持自动扩容。
- **允许重复元素**：可以存储多个相同的元素。
- **允许 `null` 值**：支持插入 `null` 元素。
- **非线程安全**：多线程环境下需手动同步（如使用 `Collections.synchronizedList`）。
- **随机访问高效**：通过索引访问元素的时间复杂度为 `O(1)`。
- **插入/删除效率较低**：中间位置的增删操作需要移动元素（时间复杂度为 `O(n)`）。

#### 底层实现原理

数据结构：

- 底层基于 `Object[] elementData` 存储元素。
- 关键变量：
  - `transient Object[] elementData`：存储元素的数组。
  - `private int size`：当前元素数量（实际大小）。
  - `DEFAULT_CAPACITY`：默认初始容量为 `10`（JDK 8+ 中首次添加元素时扩容到 10）。

动态扩容机制：

- **触发条件**：当插入元素时，若当前容量不足（`size >= elementData.length`），触发扩容。
- 扩容规则：
  - 新容量 = 原容量 + 原容量右移 1 位（即 `1.5` 倍）。
  - 若计算后的容量仍不足，则使用 `minCapacity`（所需最小容量）。

```java
// 扩容代码片段（简化版）
int newCapacity = oldCapacity + (oldCapacity >> 1);
```

> [!TIP]
>
> - 若已知元素数量，可通过构造函数或 `ensureCapacity()` 预分配容量，避免频繁扩容。



#### 定义

由于 `ArrayList`实现了 List 接口，所以 变量的类型可以是 List 类型；new 关键字声明后的尖括号中可以不再指定元素的类型，因为编译器可以通过前面尖括号中的类型进行智能推断。

```java
ArrayList<String> alist = new ArrayList<String>();
// or
List<String> alist = new ArrayList<>();
```

如果非常确定 ArrayList 中元素的个数，在创建的时候还可以指定初始大小。可以有效地避免在添加新的元素时进行不必要的扩容。

```java
List<String> alist = new ArrayList<>(20);
```

通过集合初始化：

```java
ArrayList<String> list = new ArrayList<>(Arrays.asList("A", "B"));
```

#### 常用方法

| 方法名                | 功能                   | 时间复杂度           |
| --------------------- | ---------------------- | -------------------- |
| `add(E e)`            | 末尾添加元素           | `O(1)`（分摊）       |
| `add(int index, E e)` | 指定位置插入元素       | `O(n)`（需移动元素） |
| `get(int index)`      | 获取指定索引的元素     | `O(1)`               |
| `set(int index, E e)` | 替换指定索引的元素     | `O(1)`               |
| `remove(int index)`   | 删除指定索引的元素     | `O(n)`（需移动元素） |
| `remove(Object o)`    | 删除第一个匹配的元素   | `O(n)`               |
| `size()`              | 获取元素数量           | `O(1)`               |
| `isEmpty()`           | 判断是否为空           | `O(1)`               |
| `contains(Object o)`  | 判断是否包含某元素     | `O(n)`               |
| `indexOf(Object o)`   | 获取元素首次出现的索引 | `O(n)`               |
| `clear()`             | 清空所有元素           | `O(n)`               |

```java
ArrayList<String> list = new ArrayList<>();
list.add("Java"); 
list.add(0, "Python"); // 插入到索引 0
System.out.println(list.get(1)); // 输出 "Java"
list.set(0, "C++"); 
list.remove(1); // 删除索引 1 的元素
list.contains("C++"); // true
```

#### 线程安全

**非线程安全**：`ArrayList` 不是线程安全的，多线程环境下并发修改会抛出 `ConcurrentModificationException`。

可以适用手动同步，使用 `Collections.synchronizedList` 包装：

```java
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
```

可以使用并发集合：如 `CopyOnWriteArrayList`（适用于读多写少的场景）：

```java
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
```

#### 性能优化

**预分配容量**：避免频繁扩容，提高性能。

```
ArrayList<String> list = new ArrayList<>(1000); // 初始容量 1000
```

**减少扩容次数**：通过 `ensureCapacity(int minCapacity)` 手动扩容。

```
list.ensureCapacity(2000); // 确保容量至少为 2000
```

**释放未使用内存**：通过 `trimToSize()` 缩小底层数组容量。

```
list.trimToSize(); // 底层数组容量调整为实际元素数量
```

#### 常见异常

**`IndexOutOfBoundsException`**

- 访问或删除不存在的索引（如 `list.get(100)` 但 `size < 100`）。

**`ConcurrentModificationException`**

遍历过程中直接修改集合（非通过迭代器）

```java
// error
for (String s : list) {
    if (s.equals("removeMe")) list.remove(s); // 抛出 ConcurrentModificationException
}
// ok
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    if (it.next().equals("removeMe")) it.remove();
}
```

#### 与 `LinkedList` 的对比

| 特性              | `ArrayList`        | `LinkedList`                     |
| ----------------- | ------------------ | -------------------------------- |
| 数据结构          | 动态数组           | 双向链表                         |
| 随机访问          | `O(1)`             | `O(n)`                           |
| 插入/删除（中间） | `O(n)`             | `O(1)`                           |
| 内存占用          | 连续空间，节省内存 | 节点需存储前后指针，占用更多内存 |
| 线程安全          | 非线程安全         | 非线程安全                       |
| 适用场景          | 高频随机访问       | 频繁插入/删除                    |

#### 应用场景

- 适合 `ArrayList` 的场景：
  - 需要频繁通过索引访问元素。
  - 数据量不大且插入/删除操作较少。
  - 读多写少的场景（如缓存、查询密集型操作）。
- 不适合 `ArrayList` 的场景：
  - 频繁在中间位置插入/删除元素。
  - 多线程并发写入（需额外同步开销）。

### `HashMap`

`HashMap` 是 Java 集合框架中实现 `Map` 接口的哈希表结构，用于存储键值对（Key-Value Pair）。
 它继承自 `AbstractMap`，并实现了 `Map` 接口。

#### 核心特性

- **键唯一性**：Key 不可重复，Value 可以重复。
- **允许 `null` 键和值**：Key 和 Value 都可以为 `null`。
- **非线程安全**：多线程环境下需手动同步。
- **无序性**：遍历顺序不保证与插入顺序一致（除非使用 `LinkedHashMap`）。
- **高效性**：基于哈希表实现，查询、插入、删除的平均时间复杂度为 `O(1)`。

#### 底层数据结构

JDK 1.8 及之后的 `HashMap` 采用 **数组 + 链表 + 红黑树** 的复合结构：

**数组（哈希桶）**

- **存储基础**：内部维护一个 `Node<K,V>[] table` 数组，每个元素称为一个“桶”（Bucket）。
- **容量特性**：数组长度始终是 2 的幂（如 16、32、64），便于通过位运算快速定位索引。
- **初始容量**：默认初始容量为 16，负载因子为 0.75（即当元素数量超过 `容量 × 负载因子` 时触发扩容）。

**链表**

- **冲突解决**：当多个键的哈希值映射到同一桶时，这些键值对以链表形式存储。
- **链表节点**：每个节点包含 `key`、`value`、`hash` 和 `next` 指针。

**红黑树**

- **优化查询**：当链表长度超过阈值（默认 8）且数组长度 ≥ 64 时，链表转换为红黑树，将查询复杂度从 `O(n)` 优化到 `O(log n)`。
- **退化条件**：当红黑树节点数小于 6 时，退化为链表。

#### 定义

```java
HashMap<String, String> map = new HashMap<>();
```

#### 常用方法

**增加元素**

- 若桶为空，直接插入新节点。
- 若桶不为空：
  - 比较 Key 是否相同（`equals()`），相同则覆盖旧值。
  - 否则，遍历链表或红黑树插入新节点。
- **扩容判断**：插入后若元素数量超过阈值，触发扩容。

```java
HashMap<String, String> map = new HashMap<>();
map.put("name", "leirp");
```

**查询元素**

遍历链表或红黑树，通过 `equals()` 比较 Key，返回匹配的 Value。

```java
map.get("name")
```

**删除元素**

遍历链表或红黑树，找到匹配的 Key 并删除节点。

```java
map.remove("name")
```

**遍历**

```java
HashMap<String, String> map = new HashMap<>();
        map.put("name", "leirp");
        map.put("age", "18");
        map.put("sex", "male"); 
        for (Map.Entry<String,String> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
```



#### 核心原理

**哈希计算**

- 哈希值生成：

  ```
  static final int hash(Object key) {
      int h;
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
  ```

  - **扰动函数**：通过 `(h = key.hashCode()) ^ (h >>> 16)` 打散高位和低位，减少哈希冲突。

- 索引定位

  ```
  index = (n - 1) & hash; // n 为数组长度（必须是 2 的幂）
  ```

**扩容机制**

- **触发条件**：当元素数量超过 `threshold = capacity × loadFactor` 时触发扩容。
- 扩容规则：
  - 新容量为原容量的 2 倍（保持 2 的幂）。
  - 重新计算所有元素的哈希位置（Rehash），迁移至新数组。
  - **JDK 1.8 优化**：通过高低位拆分避免二次哈希计算（链表节点分为高位和低位两部分）。

**链表转红黑树**

- **阈值**：链表长度 ≥ 8 且数组长度 ≥ 64 时，链表转为红黑树。
- **目的**：降低极端情况下的查询复杂度。

#### 线程安全问题

**非线程安全原因**：

- 多线程扩容时可能导致 **死循环**（链表成环）或 **数据丢失**。
- 示例：JDK 1.7 中头插法扩容导致死循环，JDK 1.8 改为尾插法缓解此问题，但仍不保证线程安全。

**解决方案**：

适用`Collections.synchronizedMap`，但有全局锁，性能较差。

```
Map<String, String> syncMap = Collections.synchronizedMap(new HashMap<>());
```

`ConcurrentHashMap`分段锁（JDK 1.7）或 CAS + synchronized（JDK 1.8），支持高并发。

```
Map<String, String> concurrentMap = new ConcurrentHashMap<>();
```

手动同步

```
synchronized (map) {
    map.put(key, value);
}
```

#### 性能优化

- 预分配容量

  ```java
  // 预分配容量 = 预期元素数 / 负载因子
  HashMap<String, Integer> map = new HashMap<>(100 / 0.75f);
  ```

- **负载因子调整**：默认 0.75 是时间与空间的平衡，可根据场景调整。

- 减少哈希冲突：

  - 使用高质量的 `hashCode()` 方法（如 `Objects.hash()`）。
  - 避免 Key 的哈希值重复。

####  应用场景

| 场景         | 说明                                        |
| ------------ | ------------------------------------------- |
| **缓存**     | 存储频繁访问的数据，如本地缓存。            |
| **计数器**   | 统计单词出现次数、用户访问次数。            |
| **快速检索** | 通过 Key 快速查找 Value（如字典、电话簿）。 |
| **去重**     | 利用 Key 的唯一性过滤重复数据。             |

------

#### 注意事项

- **Key 的不可变性**：建议使用不可变对象（如 `String`、`Integer`）作为 Key，避免修改后导致无法查找。
- **避免哈希冲突**：自定义类作为 Key 时，需重写 `hashCode()` 和 `equals()` 方法。
- **线程安全**：多线程环境下优先选择 `ConcurrentHashMap`。
- **迭代安全**：迭代过程中修改集合会抛出 `ConcurrentModificationException`，需使用迭代器的 `remove()` 方法。

------

#### 与 `Hashtable` 的对比

| 特性        | `HashMap`                | `Hashtable`                            |
| ----------- | ------------------------ | -------------------------------------- |
| 线程安全    | 非线程安全               | 线程安全（方法用 `synchronized` 修饰） |
| 允许 `null` | 允许 Key/Value 为 `null` | 不允许 Key/Value 为 `null`             |
| 性能        | 高（无同步开销）         | 低（全局锁）                           |
| 扩容策略    | 容量 × 2                 | 容量 × 2 + 1                           |
| 推荐使用    | 现代开发首选             | 已过时，推荐 `ConcurrentHashMap`       |