# 面向对象

Java是一种面向对象的编程语言。它基于对象的概念。

这些对象具有两个特征：

- 状态（字段）
- 行为（方法）

## 类

在用Java创建对象之前，需要定义一个类。类是对象的蓝图。

一个类可以包含：

- 字段（Field）
- 方法（Method）
- 构造方法（Constructor）

```java
public class Person {
    private String name;
    private String age;
    private String sex;

    public Person() {
    } // 如果构造方法为空，可以省略

    public void say() {
        name = "张三";
        age = "18";
        sex = "男";
        System.out.println("我的名字是：" + name + "，年龄是：" + age + "，性别是：" + sex);
    }
}
```

## 对象

### 创建对象

```java
public class Person {
    private String name;
    private int age;
    private int sex;

    private void eat() {}
    private void sleep() {}
    private void dadoudou() {}

    public static void main(String[] args) {
        Person person = new Person();
        System.out.println(person.name);
        System.out.println(person.age);
        System.out.println(person.sex);
    }
}
```

### 初始化对象

#### 通过对象的引用变量

通过对象的引用变量，可以直接对字段进行初始化

```java
public class Person {
    private String name;
    private int age;
    private int sex;

    public static void main(String[] args) {
        Person person = new Person();
        person.name = "沉默王二";
        person.age = 18;
        person.sex = 1;
        
        System.out.println(person.name);
        System.out.println(person.age);
        System.out.println(person.sex);
    }
}
```

#### 通过方法初始化

在 类中新增方法，然后在新建对象后传参进行初始化

```java
public class Person {
    private String name;
    private int age;
    private int sex;

    public void initialize(String n, int a, int s) {
        name = n;
        age = a;
        sex = s;
    }

    public static void main(String[] args) {
        Person person = new Person();
        person.initialize("沉默王二",18,1);

        System.out.println(person.name);
        System.out.println(person.age);
        System.out.println(person.sex);
    }
}
```

#### 通过构造方法初始化

```java
public class Person {
    private String name;
    private int age;
    private int sex;

    public Person(String name, int age, int sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    public static void main(String[] args) {
        Person person = new Person("沉默王二", 18, 1);

        System.out.println(person.name);
        System.out.println(person.age);
        System.out.println(person.sex);
    }
}
```

## 变量

### 局部变量

在方法体内声明的变量被称为局部变量，该变量只能在该方法内使用，类中的其他方法并不知道该变量。

```java
// 其中 a、b、c 就是局部变量，它们只能在当前这个 main 方法中使用。
public class LocalVariable {
    public static void main(String[] args) {
        int a = 10;
        int b = 10;
        int c = a + b;
        System.out.println(c);
    }
}
```

声明局部变量时的注意事项：

- 局部变量声明在方法、构造方法或者语句块中。
- 局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，将会被销毁。
- 访问修饰符不能用于局部变量。
- 局部变量只在声明它的方法、构造方法或者语句块中可见。
- 局部变量是在栈上分配的。
- 局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。

### 成员变量

在类内部但在方法体外声明的变量称为成员变量，或者实例变量，或者字段。之所以称为实例变量，是因为该变量只能通过类的实例（对象）来访问。

```java
public class InstanceVariable {
    int data = 88;
    public static void main(String[] args) {
        InstanceVariable iv = new InstanceVariable();
        System.out.println(iv.data); // 88
    }
}
```

声明成员变量时的注意事项：

- 成员变量声明在一个类中，但在方法、构造方法和语句块之外。
- 当一个对象被实例化之后，每个成员变量的值就跟着确定。
- 成员变量在对象创建的时候创建，在对象被销毁的时候销毁。
- 成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。
- 成员变量可以声明在使用前或者使用后。
- 访问修饰符可以修饰成员变量。
- 成员变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把成员变量设为私有。通过使用访问修饰符可以使成员变量对子类可见；成员变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。

### 静态变量

通过 static 声明的变量被称为静态变量（类变量），它可以直接被类访问

```java
public class StaticVariable {
    static int data = 99;
    public static void main(String[] args) {
        System.out.println(StaticVariable.data); // 99
    }
}
```

声明静态变量时的注意事项：

- 静态变量在类中以 static 关键字声明，但必须在方法构造方法和语句块之外。
- 无论一个类创建了多少个对象，类只拥有静态变量的一份拷贝。
- 静态变量除了被声明为常量外很少使用。
- 静态变量储存在静态存储区。
- 静态变量在程序开始时创建，在程序结束时销毁。
- 与成员变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。
- 静态变量的默认值和实例变量相似。
- 静态变量还可以在静态语句块中初始化。

### 常量

在 Java 中，有些数据的值是不会发生改变的，这些数据被叫做常量——使用 [final 关键字](https://javabetter.cn/oo/final.html)修饰的成员变量。常量的值一旦给定就无法改变！

常量在程序运行过程中主要有 2 个作用：

- 代表常数，便于修改（例如：圆周率的值，`final double PI = 3.14`）
- 增强程序的可读性（例如：常量 UP、DOWN 用来代表上和下，`final int UP = 0`）

Java 要求常量名必须大写。来看下面这个示例：

```java
public class FinalVariable {
    final String CHEN = "沉";
    static final String MO = "默";
    public static void main(String[] args) {
        FinalVariable fv = new FinalVariable();
        System.out.println(fv.CHEN);
        System.out.println(MO);
    }
}
```

## 方法

### java 中的方法

方法用来实现代码的可重用性，我们编写一次方法，并多次使用它。通过增加或者删除方法中的一部分代码，就可以提高整体代码的可读性。只有方法被调用时，它才会执行。Java 中最有名的方法当属 `main()` 方法，这是程序的入口。

### 声明方法

![17-02](../../images/17-02.png)

**访问权限**：它指定了方法的可见性。Java 提供了四种[访问权限修饰符](https://javabetter.cn/oo/access-control.html)：

- public：该方法可以被所有类访问。
- private：该方法只能在定义它的类中访问。
- protected：该方法可以被同一个包中的类，或者不同包中的子类访问。
- default：如果一个方法没有使用任何访问权限修饰符，那么它是 package-private 的，意味着该方法只能被同一个包中的类可见。

**返回类型**：方法返回的数据类型，可以是基本数据类型、对象和集合，如果不需要返回数据，则使用 void 关键字。

**方法名**：方法名最好反应出方法的功能，比如，我们要创建一个将两个数字相减的方法，那么方法名最好是 subtract。方法名最好是一个动词，并且以小写字母开头。如果方法名包含两个以上单词，那么第一个单词最好是动词，然后是形容词或者名词，并且要以驼峰式的命名方式命名。

**参数**：参数被放在一个圆括号内，如果有多个参数，可以使用逗号隔开。参数包含两个部分，参数类型和参数名。如果方法没有参数，圆括号是空的。

**方法签名**：每一个方法都有一个签名，包括方法名和参数。

**方法体**：方法体放在一对花括号内，把一些代码放在一起，用来执行特定的任务。

### 实例方法

没有使用 [static 关键字](https://javabetter.cn/oo/static.html)修饰，但在类中声明的方法被称为实例方法，在调用实例方法之前，必须创建类的对象。

```java
public class InstanceMethodExample {
    public static void main(String[] args) {
        InstanceMethodExample instanceMethodExample = new InstanceMethodExample();
        System.out.println(instanceMethodExample.add(1, 2));
    }

    public int add(int a, int b) {
        return a + b;
    }
}
```

实例方法有两种特殊类型：

- getter 方法
- setter 方法

getter 方法用来获取私有变量（private 修饰的字段）的值，setter 方法用来设置私有变量的值。

```java
public class Person {
    private String name;
    private int age;
    private int sex;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getSex() {
        return sex;
    }

    public void setSex(int sex) {
        this.sex = sex;
    }
}
```

getter 方法以 get 开头，setter 方法以 set 开头。

### 静态方法

有 [static 关键字](https://javabetter.cn/oo/static.html)修饰的方法就叫做静态方法。

```java
public class StaticMethodExample {
    public static void main(String[] args) {
        System.out.println(add(1,2));
    }

    public static int add(int a, int b) {
        return a + b;
    }
}
```



当我们调用静态方法的时候，就不需要 new 出来类的对象，就可以直接调用静态方法了，一些工具类的方法都是静态方法，比如说 hutool 工具类库，里面有大量的静态方法可以直接调用。

### 抽象方法

没有方法体的方法被称为抽象方法，它总是在[抽象类](https://javabetter.cn/oo/abstract.html)中声明。这意味着如果类有抽象方法的话，这个类就必须是抽象的。可以使用 abstract 关键字创建抽象方法和抽象类。

```
abstract class AbstractDemo {
    abstract void display();
}
```

当一个类继承了抽象类后，就必须重写抽象方法：

```java
public class MyAbstractDemo extends AbstractDemo {
    @Override
    void display() {
        System.out.println("重写了抽象方法");
    }

    public static void main(String[] args) {
        MyAbstractDemo myAbstractDemo = new MyAbstractDemo();
        myAbstractDemo.display();
    }
}
```

如果抽象子类继承自抽象父类，则其可以不重写抽象父类中提供的抽象方法。

```java
abstract class Animal {
    public abstract void makeSound(); // 抽象方法
}

abstract class Dog extends Animal {
    // 可以根据实际需要决定是否要重写 makeSound 方法，即使不重写也不会出错
}
```



### 方法类型

#### 预先定义方法（标准库方法）

 标准库方法是Java中的内置方法，可以随时使用。这些标准库与Java类库（JCL）一起出现在JVM和JRE的Java归档文件（*.jar）中。

Java 提供了大量预先定义好的方法供我们调用，也称为标准类库方法，或者内置方法。比如说 String 类的 `length()`、`equals()`、`compare()` 方法，以及最常用的 `println()` 方法，用来在控制台打印信息。

#### 用户自定义方法

当预先定义方法无法满足我们的要求时，就需要自定义一些方法。

## 可变参数

允许方法使用任意多个、类型相同（`is-a`）的值作为参数。可变参数必须放在列表参数的最后，否则会报错。

```java
public static void main(String[] args) {
    print("沉");
    print("沉", "默");
    print("沉", "默", "王");
    print("沉", "默", "王", "二");
}

public static void print(String... strs) {
    for (String s : strs)
        System.out.print(s);
    System.out.println();
}
```



**当使用可变参数的时候，实际上是先创建了一个数组，该数组的大小就是可变参数的个数，然后将参数放入数组当中，再将数组传递给被调用的方法**。

## 构造方法

在 Java 中，构造方法是一种特殊的方法，当一个类被实例化的时候，就会调用构造方法。只有在构造方法被调用的时候，对象才会被分配内存空间。每次使用 `new` 关键字创建对象的时候，构造方法至少会被调用一次。

如果在一个类中没有看见构造方法，并不是因为构造方法不存在，而是被缺省了，编译器会给这个类提供一个默认的构造方法。就是说，Java 有两种类型的构造方法：**无参构造方法和有参构造方法**。

之所以叫它构造方法，是因为对象在创建的时候，需要通过构造方法初始化值——描写对象有哪些初始化状态。

### 创建构造方法的规则

- 构造方法的名字必须和类名一样；
- 构造方法没有返回类型，包括 void；
- 构造方法不能是抽象的（abstract）、静态的（static）、最终的（final）、同步的（synchronized）。
  - 由于构造方法不能被子类继承，所以用 final 和 abstract 关键字修饰没有意义；
  - 构造方法用于初始化一个对象，所以用 static 关键字修饰没有意义；
  - 多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 关键字修饰没有必要。

```java
class class_name {
    public class_name(){}    // 默认无参构造方法
    public ciass_name([paramList]){}    // 定义有参数列表的构造方法
    …
    // 类主体
}
```

如果用 void 声明构造方法的话，编译时不会报错，但 Java 会把这个所谓的“构造方法”当成普通方法来处理。

```
public class Demo {
    void Demo(){ }
}
```

可以使用[访问权限修饰符](https://javabetter.cn/oo/access-control.html)（private、protected、public、default）来修饰构造方法，访问权限修饰符决定了构造方法的创建方式。

### 默认构造方法

如果一个构造方法中没有任何参数，那么它就是一个默认构造方法，也称为无参构造方法。

```java
public class Bike {
    Bike(){
        System.out.println("一辆自行车被创建");
    }

    public static void main(String[] args) {
        Bike bike = new Bike();
    }
}
```

通常情况下，无参构造方法是可以缺省的，我们开发者并不需要显式的声明无参构造方法，把这项工作交给编译器就可以了。

默认构造方法的目的主要是为对象的字段提供默认值。

```java
public class Person {
    private String name;
    private int age;

    public static void main(String[] args) {
        Person p = new Person();
        System.out.println("姓名 " + p.name + " 年龄 " + p.age);
    }
}

```

默认构造方法初始化了 name 和 age 的值，name 是 String 类型，所以默认值为 null，age 是 int 类型，所以默认值为 0。如果没有默认构造方法的话，这项工作就无法完成。

### 有参构造方法

有参数的构造方法被称为有参构造方法，参数可以有一个或多个。有参构造方法可以为不同的对象提供不同的值。当然，也可以提供相同的值。

```java
public class ParamConstructorPerson {
    private String name;
    private int age;

    public ParamConstructorPerson(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void out() {
        System.out.println("姓名 " + name + " 年龄 " + age);
    }

    public static void main(String[] args) {
        ParamConstructorPerson p1 = new ParamConstructorPerson("沉默王二",18);
        p1.out();

        ParamConstructorPerson p2 = new ParamConstructorPerson("沉默王三",16);
        p2.out();
    }
}
```

### 重载构造方法

构造方法和方法类似，只不过没有返回类型。它也可以像方法一样被[重载](https://javabetter.cn/basic-extra-meal/override-overload.html)。构造方法的重载也很简单，只需要提供不同的参数列表即可。编译器会通过参数的数量来决定应该调用哪一个构造方法。

```java
public class OverloadingConstrutorPerson {
    private String name;
    private int age;
    private int sex;

    public OverloadingConstrutorPerson(String name, int age, int sex) {
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    public OverloadingConstrutorPerson(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void out() {
        System.out.println("姓名 " + name + " 年龄 " + age + " 性别 " + sex);
    }

    public static void main(String[] args) {
        OverloadingConstrutorPerson p1 = new OverloadingConstrutorPerson("沉默王二",18, 1);
        p1.out();

        OverloadingConstrutorPerson p2 = new OverloadingConstrutorPerson("沉默王三",16);
        p2.out();
    }
}
```

### 构造方法和方法的区别

![17-01](../../images/17-01.png)

### 构造方法复制对象

```java
public class CopyValuePerson {
    private String name;
    private int age;

    public CopyValuePerson(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public CopyValuePerson() {
    }

    public void out() {
        System.out.println("姓名 " + name + " 年龄 " + age);
    }

    public static void main(String[] args) {
        CopyValuePerson p1 = new CopyValuePerson("沉默王二",18);
        p1.out();

        CopyValuePerson p2 = new CopyValuePerson();
        p2.name = p1.name;
        p2.age = p1.age;
        
        p2.out();
    }
}
```

## 访问权限修饰符

在 Java 中，提供了四种访问权限控制：

- 默认访问权限（包访问权限）
- public
- private
- protected

### 修饰类

- 默认访问权限（包访问权限）：用来修饰类的话，表示该类只对同一个包中的其他类可见。
- public：用来修饰类的话，表示该类对其他所有的类都可见。

### 修饰方法和变量

- 默认访问权限（包访问权限）：如果一个类的方法或变量被包访问权限修饰，也就意味着只能在同一个包中的其他类中显示地调用该类的方法或者变量，在不同包中的类中不能显式地调用该类的方法或变量。
- private：如果一个类的方法或者变量被 private 修饰，那么这个类的方法或者变量只能在该类本身中被访问，在类外以及其他类中都不能显式的进行访问。
- protected：如果一个类的方法或者变量被 protected 修饰，对于同一个包的类，这个类的方法或变量是可以被访问的。对于不同包的类，只有继承于该类的类才可以访问到该类的方法或者变量。
- public：被 public 修饰的方法或者变量，在任何地方都是可见的。

### 其他细节

Java 中的包主要是为了防止类文件命名冲突以及方便进行代码组织和管理；

对于一个 Java 源代码文件，如果存在 public 类的话，只能有一个 public 类，且此时源代码文件的名称必须和 public 类的名称完全相同。

| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包) | 其他包 |
| :---------- | :----- | :------- | :------------- | :------------- | :----- |
| `public`    | Y      | Y        | Y              | Y              | Y      |
| `protected` | Y      | Y        | Y              | Y/N            | N      |
| `default`   | Y      | Y        | Y              | N              | N      |
| `private`   | Y      | N        | N              | N              | N      |

## 代码初始化块

代码初始化块用于初始化一些成员变量。 

在java 中，可以直接通过 `=` 操作符对成员变量进行初始化，但是无法进行更复杂的操作，比如为集合填充值。

```java
class Bike{  
    int speed=100;  
}

public class Bike {
    List<String> list;

    {
        list = new ArrayList<>();
        list.add("沉默王二");
        list.add("沉默王三");
    }

    public static void main(String[] args) {
        System.out.println(new Bike().list);
    }
}
```

### 执行顺序

对象在初始化的时候会先调用构造方法，这是毫无疑问的，只不过，构造方法在执行的时候会把代码初始化块放在构造方法中其他代码之前。

```java
public class Car {
    Car() {
        System.out.println("构造方法");
    }

    {
        System.out.println("代码初始化块");
    }

    public static void main(String[] args) {
        new Car();
    }
}
// 编译后的内容
public class Person {
    Person() {
        System.out.println("代码初始化块");
        System.out.println("构造方法");
    }

    public static void main(String[] args) {
        new Person();
    }
}
```

在默认情况下，子类的构造方法在执行的时候会主动去调用父类的构造方法。也就是说，其实是构造方法先执行的，再执行的代码初始化块。

```java
class A {
    A () {
        System.out.println("父类构造方法");
    }
}
public class B extends A{
    B() {
        System.out.println("子类构造方法");
    }

    {
        System.out.println("代码初始化块");
    }

    public static void main(String[] args) {
        new B();
    }
}
```

## 抽象类

### 定义抽象类

定义抽象类的时候需要用到关键字 `abstract`

```java
abstract class AbstractPlayer {
}

```

### 抽象类的特征

抽象类是不能实例化的，尝试通过 `new` 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。

```java
public static void main(String[] args) {
        new AbstractPlayer();
    }
// 类是抽象的  无法实例化
```

虽然抽象类不能实例化，但可以有子类。子类通过 `extends` 关键字来继承抽象类。

```java
public class BasketballPlayer extends AbstractPlayer {
}
```

如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。

```java
// 错误的代码，第一处在类级别上，提示“这个类必须通过 abstract 关键字定义”，第二处在尝试定义 abstract 的方法上，提示“抽象方法所在的类不是抽象的”
public class Person {
    public abstract void  sayHello() {
        System.out.println("hello world");
    }
}  
```

抽象类中既可以定义抽象方法，也可以定义普通方法

```java
public abstract class AbstractPlayer {
    abstract void play();
    
    public void sleep() {
        System.out.println("运动员也要休息而不是挑战极限");
    }
}
```

抽象类派生的子类必须实现父类中定义的抽象方法，如果没有实现的话，编译器会提示“子类必须实现抽象方法”。

```java
public class BasketballPlayer extends AbstractPlayer {
    @Override
    void play() {
        System.out.println("我是张伯伦，篮球场上得过 100 分");
    }
}
```

### 使用场景

当希望一些通用的功能被多个子类复用的时候，就可以使用抽象类。

```java
abstract class AbstractPlayer {
    public void sleep() {
        System.out.println("运动员也要休息而不是挑战极限");
    }
}
//子类 BasketballPlayer 继承了 AbstractPlayer 类：
class BasketballPlayer extends AbstractPlayer {
}
//BasketballPlayer 的对象可以直接调用父类的 sleep() 方法：
BasketballPlayer basketballPlayer = new BasketballPlayer();
basketballPlayer.sleep();
```

当需要在抽象类中定义好 API，然后在子类中扩展实现的时候就可以使用抽象类。

```java
abstract class AbstractPlayer {
    abstract void play();
}

public class BasketballPlayer extends AbstractPlayer {
    @Override
    void play() {
        System.out.println("我是张伯伦，我篮球场上得过 100 分，");
    }
}
```

### 完整示例

假设现在有一个文件，里面的内容非常简单，只有一个“Hello World”，现在需要有一个读取器将内容从文件中读取出来，最好能按照大写的方式，或者小写的方式来读。

这时候，最好定义一个抽象类 BaseFileReader：

```java
/**
 * 抽象类，定义了一个读取文件的基础框架，其中 mapFileLine 是一个抽象方法，具体实现需要由子类来完成
 */
abstract class BaseFileReader {
    protected Path filePath; // 定义一个 protected 的 Path 对象，表示读取的文件路径

    /**
     * 构造方法，传入读取的文件路径
     * @param filePath 读取的文件路径
     */
    protected BaseFileReader(Path filePath) {
        this.filePath = filePath;
    }

    /**
     * 读取文件的方法，返回一个字符串列表
     * @return 字符串列表，表示文件的内容
     * @throws IOException 如果文件读取出错，抛出该异常
     */
    public List<String> readFile() throws IOException {
        return Files.lines(filePath) // 使用 Files 类的 lines 方法，读取文件的每一行
                .map(this::mapFileLine) // 对每一行应用 mapFileLine 方法，将其转化为指定的格式
                .collect(Collectors.toList()); // 将处理后的每一行收集到一个字符串列表中，返回
    }

    /**
     * 抽象方法，子类需要实现该方法，将文件中的每一行转化为指定的格式
     * @param line 文件中的每一行
     * @return 转化后的字符串
     */
    protected abstract String mapFileLine(String line);
}
```

BaseFileReader 类设计的非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了

```java
// 小写的方式：
class LowercaseFileReader extends BaseFileReader {
    protected LowercaseFileReader(Path filePath) {
        super(filePath);
    }

    @Override
    protected String mapFileLine(String line) {
        return line.toLowerCase();
    }
}
// 大写的方式：
class UppercaseFileReader extends BaseFileReader {
    protected UppercaseFileReader(Path filePath) {
        super(filePath);
    }

    @Override
    protected String mapFileLine(String line) {
        return line.toUpperCase();
    }
}
```



### 总结

- 1、抽象类不能被实例化。
- 2、抽象类应该至少有一个抽象方法，否则它没有任何意义。
- 3、抽象类中的抽象方法没有方法体。
- 4、抽象类的子类必须给出父类中的抽象方法的具体实现，除非该子类也是抽象类。

## 接口

在Java中，接口定义了其他类必须实现的一组规范。

### 定义接口

接口通过 interface 关键字来定义，它可以包含一些常量和方法，

```java
public interface Electronic {
    // 常量
    String LED = "LED";

    // 抽象方法
    int getElectricityUse();

    // 静态方法
    static boolean isEnergyEfficient(String electtronicType) {
        return electtronicType.equals(LED);
    }

    // 默认方法
    default void printDescription() {
        System.out.println("电子");
    }
}
```

### 核心知识点

- 接口中定义的变量会在编译的时候自动加上 `public static final` 修饰符
- **没有使用 `private`、`default` 或者 `static` 关键字修饰的方法是隐式抽象的**，在编译的时候会自动加上 `public abstract` 修饰符。
- **从 Java 8 开始，接口中允许有静态方法**
- **从 Java 8 开始，接口中允许定义 `default` 方法**
- **接口不允许直接实例化**，否则编译器会报错
- **接口可以是空的**，既可以不定义变量，也可以不定义方法。
- **不能在定义接口的时候使用 final 关键字**，否则会报编译错误，因为接口就是为了让子类实现的，而 final 阻止了这种行为。
- **接口的抽象方法不能是 private、protected 或者 final**，否则编译器都会报错。
- **接口的变量是隐式 `public static final`（常量）**，所以其值无法改变。

### 实现接口

像抽象类一样，我们无法创建接口的对象。但是，我们可以在其他类中实现接口。在Java中，我们使用 implements关键字来实现接口。

```java
interface Polygon {
    void getArea(int length, int breadth);
}

class Rectangle implements Polygon {
    public void getArea(int length, int breadth) {
        System.out.println("矩形的面积是 " + (length * breadth));
    }
}

class Main {
    public static void main(String[] args) {
        Rectangle r1 = new Rectangle();
        r1.getArea(5, 6);
    }
}
```

### 接口的作用

####  定义行为规范（约定行为）

- **强制实现规范**：接口定义了一组方法的签名（方法名、参数、返回类型），任何实现该接口的类都必须提供这些方法的具体实现。这种约束确保了不同类在功能上的一致性。

```java
public interface Bicycle {
    void changeCadence(int newValue);
    void changeGear(int newValue);
}

public class ACMEBicycle implements Bicycle {
    // 必须实现接口中的所有方法
    public void changeCadence(int newValue) { ... }
    public void changeGear(int newValue) { ... }
}
```

#### 支持多继承（多重实现）

- **Java 的单继承限制**：Java 的类只能单继承（一个类只能有一个直接父类），但接口允许一个类实现多个接口，从而变相实现“多继承”。
- **灵活组合功能**：通过实现多个接口，类可以灵活地组合不同的行为。

```java
public interface Flyable {
    void fly();
}

public interface Swimmable {
    void swim();
}

public class Duck implements Flyable, Swimmable {
    public void fly() { ... }
    public void swim() { ... }
}
```

#### 解耦合（降低代码依赖）

- **接口与实现分离**：接口定义行为，具体实现由类完成。调用者只需要依赖接口，而无需关心具体实现，从而降低代码的耦合度。

```java
public interface Payment {
    void pay(double amount);
}

public class CreditCardPayment implements Payment {
    public void pay(double amount) { ... }
}

public class ShoppingCart {
    private Payment paymentMethod;
    public void checkout(double total) {
        paymentMethod.pay(total); // 依赖接口，而非具体实现
    }
}
// ShoppingCart 类通过接口 Payment 调用支付方法，无需知道具体是信用卡支付还是支付宝支付。
```

#### 实现多态性

- **接口变量指向不同实现**：通过接口类型的变量，可以动态绑定到不同的实现类对象，实现运行时多态。

```
Payment payment = new CreditCardPayment(); // 接口变量指向信用卡支付
payment.pay(100.0);

payment = new AlipayPayment(); // 动态切换为支付宝支付
payment.pay(100.0);
```

#### 标记接口（标识角色）

- **无方法的接口**：标记接口（如 `Serializable`）没有定义任何方法，仅用于标识某个类具备特定功能或用途。

```
public interface Serializable { } // 标记类可序列化

public class User implements Serializable { 
    // 该类可被序列化
}
```

#### 函数式接口

- **单抽象方法接口**：函数式接口仅包含一个抽象方法，可以结合 Lambda 表达式简化代码（java 8+）。

```java
@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);
}

public class Main {
    public static void main(String[] args) {
        Calculator add = (a, b) -> a + b; // Lambda 实现接口方法
        System.out.println(add.calculate(2, 3)); // 输出 5
    }
}
```

### 实际应用场景

1. 团队协作

   ：通过接口统一方法名和参数，避免不同开发者对相同功能的命名混乱。

   - **示例**：多个程序员实现不同数据库的连接时，接口统一方法名（如 `connect()` 和 `close()`）。

2. 框架设计

   ：框架通过接口定义扩展点，用户通过实现接口自定义功能。

   - **示例**：Spring 框架中的 `BeanFactoryPostProcessor` 接口。

3. 事件处理

   ：通过接口实现事件监听机制。

   - **示例**：`ActionListener` 接口用于处理按钮点击事件。

## 内部类

在 Java 中，可以将一个类定义在另外一个类里面或者一个方法里面，这样的类叫做内部类。一般来说，内部类分为成员内部类、局部内部类、匿名内部类和静态内部类。

### 成员内部类

定义在外部类的成员位置（即类中、方法外），无 `static` 修饰。

- 依赖外部类实例，必须通过外部类实例创建。如果想要在静态方法中访问成员内部类的时候，就必须先得创建一个外部类的对象，因为内部类是依附于外部类的
- 可访问外部类的所有成员（包括私有成员）。但外部类想要访问内部类的成员，必须先创建一个成员内部类的对象，再通过这个对象来访问。
- 不能定义静态成员（除非是 `static final` 常量）。

```java
public class Wanger {
    int age = 18;
    private String name = "张三";
    static double money = 1000;
    class Wang {
        int age = 81;
        public void show() {
            System.out.println(name);
            System.out.println(age);
        }
    }
    public Wanger() {
        new Wang().show(); 
    }

    public static void main(String[] args) {
       Wanger wanger =  new Wanger(); // 张三 81
       Wang wang =  wanger.new Wang();
       wang.show(); // 张三 81
    }
}
```

### 局部内部类

局部内部类是定义在一个方法或者一个作用域里面的类，所以局部内部类的生命周期仅限于作用域内。

- 作用域仅限于定义它的方法或代码块。
- 不能访问方法的非 `final` 局部变量（Java 8 后隐式要求变量为 `final` 或等效不可变）。
- 可访问外部类的所有成员。
- 局部内部类就好像一个局部变量一样，它是不能被权限修饰符修饰的，比如说 public、protected、private 和 static 等。

```java
public class Outer {
    private String outerField = "外部字段";
    public void method()
    {
        String methodField = "外部方法字段";
        System.out.println("外部方法");
        class LocalInner
        {
            private String innerField = "内部字段";
            public void show()
            {
                methodField = "外部方法字段2";  // 报错 变量 'methodField' 从内部类中访问，需要为 final 或有效 final
                System.out.println("内部方法");
                System.out.println(innerField);
                System.out.println(outerField);
            }
        }
        LocalInner localInner = new LocalInner();
        localInner.show();
    }
    public static void main(String[] args) {
        Outer outer = new Outer();
        outer.method();
    }
}
```

### 匿名内部类

没有显式类名的内部类，通常用于一次性实现接口或抽象类类为匿名内部类。匿名内部类就好像一个方法的参数一样，用完就没了，以至于我们都不需要为它专门写一个构造方法，它的名字也是由系统自动命名的。

- 没有类名，只能使用一次。
- 不能有构造方法（但可以传参）。
- 常用于事件监听、线程任务等场景。

```java
public class ThreadDemo {
    public static void main(String[] args) {
        Thread t = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        });
        t.start();
    }
}
```

匿名内部类是唯一一种没有构造方法的类。就上面的写法来说，匿名内部类也不允许我们为其编写构造方法，因为它就像是直接通过 new 关键字创建出来的一个对象。

匿名内部类的作用主要是用来继承其他类或者实现接口，并不需要增加额外的方法，方便对继承的方法进行实现或者重写。

### 静态内部类

定义在外部类的成员位置，并用 `static` 修饰。

- 不依赖外部类实例，可直接通过外部类名创建。
- 只能访问外部类的静态成员。
- 可以定义静态成员。

```java
public class Outer {
    private static String staticField = "静态字段";

    // 静态嵌套类
    public static class StaticNested {
        void display() {
            System.out.println(staticField); // 只能访问外部类的静态成员
        }
    }

    public static void main(String[] args) {
        // 直接通过外部类名创建静态嵌套类
        Outer.StaticNested nested = new Outer.StaticNested();
        nested.display(); // 输出：静态字段
    }
}
```

由于 static 关键字的存在，静态内部类是不允许访问外部类中非 static 的变量和方法的

### 内部类的共性

1. **独立编译**：
    内部类会被编译为独立的 `.class` 文件，命名格式为 `外部类名$内部类名`。例如：
   - `Outer.class`
   - `Outer$Inner.class`（成员内部类）
   - `Outer$StaticNested.class`（静态嵌套类）
2. **访问权限**：
   - 成员内部类和局部类可以访问外部类的所有成员（包括私有成员）。
   - 静态嵌套类只能访问外部类的静态成员。
3. **生命周期绑定**：
   - 成员内部类的实例必须依附于外部类实例。
   - 静态嵌套类和匿名类可以独立存在。
4. **解决单继承限制**：
    内部类可以继承或实现不同的类/接口，从而绕过 Java 单继承的限制。

```java
public class Outer extends ClassA implements InterfaceA {
    public class Inner extends ClassB implements InterfaceB { }
}
```

### 内部类的使用场景

1. **事件监听与回调**：
    匿名内部类常用于 GUI 事件监听（如按钮点击）或线程任务。

   ```
   button.addActionListener(new ActionListener() {
       @Override
       public void actionPerformed(ActionEvent e) {
           System.out.println("按钮被点击！");
       }
   });
   ```

2. **封装逻辑相关类**：
    将逻辑紧密相关的类组织在一起，如汽车与其发动机（整体-部分关系）。

   ```
   public class Car {
       class Engine {
           void start() {
               System.out.println("发动机启动");
           }
       }
   }
   ```

3. **适配器模式**：
    局部内部类或匿名类可用于简化适配器实现，避免冗余代码。

4. **工具类与静态辅助**：
    静态嵌套类适合定义与外部类相关的工具类或辅助方法。

### 最佳实践与注意事项

1. **优先使用匿名类**：
   对于一次性任务（如事件监听），匿名类能简化代码。
2. **避免过度嵌套**：
   过多内部类会降低代码可读性，建议控制嵌套层级。
3. **局部变量限制**：
   局部内部类不能访问非 `final` 的局部变量，需注意变量生命周期。
4. 静态嵌套类 vs 成员内部类
   - 如果内部类不需要访问外部类实例成员，优先使用静态嵌套类。
   - 如果需要强关联外部类实例，使用成员内部类。

------

### **总结**

| **类型**   | **是否依赖外部类实例** | **访问权限**              | **适用场景**             |
| ---------- | ---------------------- | ------------------------- | ------------------------ |
| 成员内部类 | 是                     | 所有成员                  | 需要访问外部类实例成员   |
| 静态嵌套类 | 否                     | 静态成员                  | 工具类、独立辅助逻辑     |
| 局部内部类 | 是                     | 所有成员 + final 局部变量 | 方法内临时逻辑封装       |
| 匿名内部类 | 是                     | 所有成员 + final 局部变量 | 一次性任务（如事件监听） |

内部类是 Java 强大的特性之一，合理使用可以提升代码的封装性和灵活性。但在实际开发中需根据场景选择合适的内部类类型，避免过度复杂化代码结构。

## this 关键字

this 关键字有很多种用法，其中最常用的一个是，它可以作为引用变量，指向当前对象。

- 调用当前类的方法；
- `this()` 可以调用当前类的构造方法；
- this 可以作为参数在方法中传递；
- this 可以作为参数在构造方法中传递；
- this 可以作为方法的返回值，返回当前类的对象

### 指向当前对象

当方法的参数或局部变量与类的实例变量同名时，可以使用 `this` 来明确访问的是实例变量。

```java
public class WithThisStudent {
    String name;
    int age;
    int score;

    WithThisStudent(String name, int age) {
        // name = name
        // age = age
        this.name = name; //this.xxx 指向的就是实例变量，而不再是参数本身
        this.age = age;
        score = age;
    }

    void out() {
        System.out.println(name+" " + age + " " + score);
    }

    public static void main(String[] args) {
        WithThisStudent s1 = new WithThisStudent("沉默王二", 18);
        WithThisStudent s2 = new WithThisStudent("沉默王三", 16);

        s1.out();
        s2.out();
    }
}
```

- this.xxx 指向的就是实例变量，而不再是参数本身
- 如果参数名和实例变量名不同的话，就不必使用 this 关键字，但建议使用 this 关键字，这样的代码更有意义。

### 调用当前类的方法

在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动加上

```java
// 源代码
public class InvokeCurrentClassMethod {
    void method1() {}
    void method2() {
        method1();
    }

    public static void main(String[] args) {
        new InvokeCurrentClassMethod().method1();
    }
}
// 反编译的字节码
public class InvokeCurrentClassMethod {
    public InvokeCurrentClassMethod() {
    }

    void method1() {
    }

    void method2() {
        this.method1();
    }

    public static void main(String[] args) {
        (new InvokeCurrentClassMethod()).method1();
    }
}
```

### 调用当前类的构造方法（构造器链）

在一个构造方法中，可以使用 `this()` 来调用当前类的另一个构造方法。这种方式可以减少重复代码，提高可维护性。



```java
public class Person {
    private String name;
    private int age;

    // 无参构造
    public Person() {
        this("未知", 0); // 调用带参构造
    }

    // 带参构造
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

> [!WARNING]
>
> - `this()` 必须是构造方法中的**第一条语句**。
> - 不能同时使用 `this()` 和 `super()`。

### 将当前对象作为参数传递

在需要将当前对象作为参数传递给其他方法或构造函数时，可以使用 `this`。

```java
class EventNotifier {
    void notifyListeners(EventListener listener) {
        // 通知逻辑
    }

    void fireEvent() {
        notifyListeners(this); // 将当前对象作为参数传递
    }
}
```

### 方法链式调用

通过返回 `this`，可以实现方法链式调用，提升代码的可读性和流畅性。

``` 
class Calculator {
    private int result;

    public Calculator add(int value) {
        this.result += value;
        return this; // 返回当前对象以支持链式调用
    }

    public Calculator subtract(int value) {
        this.result -= value;
        return this;
    }

    public int getResult() {
        return this.result;
    }
}

// 使用方式
Calculator calc = new Calculator().add(10).subtract(5);
System.out.println(calc.getResult()); // 输出 5
```

###  在内部类中访问外部类的实例

在内部类中，`this` 默认指向的是内部类的实例。如果要访问外部类的实例，可以使用 `OuterClass.this`。

```java
public class Outer {
    private String name = "外部类";

    class Inner {
        private String name = "内部类";

        void printNames() {
            System.out.println(this.name);         // 输出：内部类
            System.out.println(Outer.this.name);    // 输出：外部类
        }
    }
}
```

### 在递归方法中引用当前对象

虽然不常见，但在某些递归方法中，可以使用 `this` 来引用当前对象。

```java
public class Factorial {
    public int calculate(int n) {
        if (n <= 1) {
            return 1;
        } else {
            return n * this.calculate(n - 1); // 使用 this 调用当前对象的方法
        }
    }
}
```

### 使用限制

静态方法属于类，而不是对象，因此不能使用 `this`。

```
public class Example {
    public static void staticMethod() {
        // this.name; // 编译错误：Cannot use this in a static context
    }
}
```

### `this` 和 `super` 的区别

| 关键字  | 用途               | 作用对象     |
| ------- | ------------------ | ------------ |
| `this`  | 访问当前对象的成员 | 当前类的对象 |
| `super` | 访问父类的成员     | 父类的对象   |

> [!WARNING]
>
> - 构造方法中不能同时使用 `this()` 和 `super()`。
> - `this()` 和 `super()` 都必须是构造方法中的第一条语句。



------

### `this` 的最佳实践

- **提高代码可读性**：即使没有变量名冲突，也可以使用 `this` 明确访问的是实例变量。
- **避免变量名冲突**：在构造方法或方法中，使用 `this` 区分同名的局部变量和实例变量。
- **简化构造逻辑**：通过构造器链调用，减少重复代码。
- **支持链式调用**：返回 `this` 可以实现更流畅的 API 设计。

------

### 总结

| 用途             | 示例                     | 说明                               |
| ---------------- | ------------------------ | ---------------------------------- |
| 区分变量         | `this.name = name;`      | 用于解决局部变量与实例变量同名问题 |
| 构造器链         | `this("未知", 0);`       | 在构造方法中调用其他构造方法       |
| 传递对象         | `notifyListeners(this);` | 将当前对象作为参数传递             |
| 链式调用         | `return this;`           | 支持方法链式调用                   |
| 内部类访问外部类 | `OuterClass.this.name`   | 在内部类中访问外部类的实例变量     |
| 静态方法中       | ❌ 不可用                 | 静态方法中不能使用 `this`          |

## `super`关键字

### `super` 的核心用法

#### 调用父类的构造方法

在子类的构造方法中，使用 `super()` 或 `super(参数列表)` 可以调用父类的构造方法，用于初始化父类部分的成员。

```java
class Animal {
    public Animal() {
        System.out.println("Animal 构造方法");
    }

    public Animal(String name) {
        System.out.println("Animal 构造方法，参数：" + name);
    }
}

class Cat extends Animal {
    public Cat() {
        super(); // 调用无参构造方法
        System.out.println("Cat 构造方法");
    }

    public Cat(String name) {
        super(name); // 调用带参构造方法
        System.out.println("Cat 构造方法，参数：" + name);
    }
}
```

- `super()` 必须是子类构造方法中的 **第一条语句**。
- 如果子类构造方法中没有显式调用 `super()`，编译器会默认插入 `super()`，即调用父类的无参构造方法。
- 如果父类没有无参构造方法，子类必须显式调用 `super(参数)`。

#### 访问父类的成员变量

当子类和父类存在 **同名的成员变量** 时，使用 `super.变量名` 可以明确访问父类的成员变量。

```java
class Animal {
    protected String name = "动物";
}

class Cat extends Animal {
    private String name = "猫";

    public void printName() {
        System.out.println("子类 name：" + this.name); // 输出 "猫"
        System.out.println("父类 name：" + super.name); // 输出 "动物"
    }
}
```

#### 调用父类的被重写方法

当子类重写了父类的方法，但希望在子类方法中保留父类的实现逻辑时，可以使用 `super.方法名()` 调用父类的方法。

```java
class Animal {
    public void eat() {
        System.out.println("动物吃东西");
    }
}

class Cat extends Animal {
    @Override
    public void eat() {
        super.eat(); // 调用父类的 eat 方法
        System.out.println("猫吃猫粮");
    }
}
```

### `super` 的特殊用法

#### 多层继承中的 `super`

在多层继承中，`super` 只能访问 **直接父类** 的成员，不能直接访问间接父类的成员。

```java
class A {
    public void show() {
        System.out.println("A");
    }
}

class B extends A {
    public void show() {
        System.out.println("B");
    }
}

class C extends B {
    public void show() {
        super.show(); // 调用 B 的 show 方法，输出 "B"
    }
}
```

#### 接口默认方法中的 `super`

在 Java 8+ 中，接口可以有默认方法。当子类实现了多个接口，且这些接口有相同的默认方法时，子类可以使用 `InterfaceName.super.method()` 来调用指定接口的默认方法。

```java
interface A {
    default void show() {
        System.out.println("A");
    }
}

interface B {
    default void show() {
        System.out.println("B");
    }
}

class C implements A, B {
    @Override
    public void show() {
        A.super.show(); // 调用 A 的默认方法
        B.super.show(); // 调用 B 的默认方法
    }
}
```

### `super` 与 `this` 的区别

| 特性         | `super`                    | `this`                            |
| ------------ | -------------------------- | --------------------------------- |
| 代表对象     | 当前对象的父类部分         | 当前对象本身                      |
| 使用场景     | 访问父类成员               | 访问当前对象成员                  |
| 构造方法调用 | `super()` 调用父类构造方法 | `this()` 调用当前类的其他构造方法 |
| 位置要求     | 必须是构造方法的第一条语句 | 必须是构造方法的第一条语句        |
| 与静态方法   | 不能在静态方法中使用       | 不能在静态方法中使用              |

### `super` 的注意事项

**`super` 不能在静态方法中使用**

- 静态方法属于类，而不是对象，因此不能使用 `super`。

**`super` 不能访问父类的私有成员**

- 父类的 `private` 成员对子类不可见，不能通过 `super` 访问。

**`super()` 必须是构造方法的第一条语句**

- 如果子类构造方法中没有显式调用 `super()`，编译器会自动插入 `super()`。
- 如果父类没有无参构造方法，子类必须显式调用 `super(参数)`。

**`super` 与 `this` 不能同时出现在构造方法的第一行**

- 构造方法中只能有一个构造方法调用（`super()` 或 `this()`）。

### `super` 的最佳实践

- **显式调用 `super()`**：即使父类有无参构造方法，也建议显式调用 `super()`，以提高代码可读性。
- **解决变量名冲突**：当子类与父类有同名变量时，使用 `super.变量名` 明确访问父类变量。
- **保留父类逻辑**：在重写父类方法时，使用 `super.方法名()` 调用父类方法，避免完全覆盖原有逻辑。
- **多层继承中谨慎使用**：`super` 只能访问直接父类，不能访问间接父类。

------

### 总结

| 用途               | 示例                            | 说明                       |
| ------------------ | ------------------------------- | -------------------------- |
| 调用父类构造方法   | `super();` 或 `super(参数);`    | 必须是构造方法的第一条语句 |
| 访问父类成员变量   | `super.name;`                   | 用于解决变量名冲突         |
| 调用父类被重写方法 | `super.eat();`                  | 用于保留父类逻辑           |
| 多层继承中的访问   | `super.show();`                 | 只能访问直接父类           |
| 接口默认方法调用   | `InterfaceName.super.method();` | 用于解决多个接口方法冲突   |

## `static` 关键字

在 Java 中，`static` 是一个非常重要的关键字，用于修饰 **类的成员**（如变量、方法、代码块、内部类），表示这些成员属于 **类本身**，而不是类的某个具体实例（对象）。它的核心作用是 **共享** 和 **独立于对象**，使得某些资源或行为可以在不创建对象的情况下直接通过类名访问。

------

### `static` 的核心作用

| 类别         | 特性                                                         |
| ------------ | ------------------------------------------------------------ |
| **共享性**   | 所有类的实例共享同一个静态成员。                             |
| **类级别**   | 静态成员属于类本身，而不是对象。                             |
| **生命周期** | 静态成员在类加载时初始化，类卸载时销毁。                     |
| **访问方式** | 可以通过类名直接访问（推荐），也可以通过对象访问（不推荐）。 |

------

### `static` 的用法详解

####  静态变量（类变量）

- **定义**：用 `static` 修饰的变量称为静态变量，也称为类变量。

- 特点：

  - 所有类的实例共享同一个静态变量。
  - 优先于对象存在，类加载时初始化。
  - 可以通过类名直接访问（推荐）：`类名.变量名`。

  

  ```
  public class Student {
      // 静态变量：所有学生共享总人数
      public static int totalStudents = 0;
  
      public Student() {
          totalStudents++;
      }
  }
  
  public class Main {
      public static void main(String[] args) {
          System.out.println(Student.totalStudents); // 输出 0
          Student s1 = new Student();
          Student s2 = new Student();
          System.out.println(Student.totalStudents); // 输出 2
      }
  }
  ```

------

#### 静态方法（类方法）

- **定义**：用 `static` 修饰的方法称为静态方法，也称为类方法。

- 特点：

  - 静态方法不能直接访问非静态成员（变量或方法）。
  - 可以通过类名直接调用（推荐）：`类名.方法名()`。

- 示例

  ```java
  public class MathUtils {
      // 静态方法：计算圆的面积
      public static double calculateCircleArea(double radius) {
          return Math.PI * radius * radius;
      }
  }
  
  public class Main {
      public static void main(String[] args) {
          double area = MathUtils.calculateCircleArea(5); // 不需要创建对象
          System.out.println("圆的面积：" + area);
      }
  }
  ```

> [!WARNING]
>
> 静态方法不能访问非静态变量和调用非静态方法。你看，三妹，我稍微改动一下代码，编译器就会报错。



#### 静态代码块

- **定义**：用 `static` 修饰的代码块称为静态代码块，静态代码块通常用来初始化一些静态变量，它会优先于 `main()` 方法执行。

- 特点：

  - 静态代码块在类加载时执行，且只执行一次。
  - 用于初始化静态变量或执行一次性操作（如加载配置文件、连接数据库等）。
  - 静态代码块先于 `main()` 方法执行，在java 7+后 没有 `main()` 方法的 Java 类无法执行

  

  ```
  public class Database {
      static {
          System.out.println("加载数据库驱动...");
      }
  }
  
  public class Main {
      public static void main(String[] args) {
          // 第一次访问 Database 类时，静态代码块会执行
          System.out.println("数据库已加载");
      }
  }
  ```

有些时候不太可能在声明的时候完成初始化，因此需要在静态代码块中完成初始化。静态代码块在初始集合的时候，非常有用。在实际的项目开发中，通常使用静态代码块来加载配置文件到内存当中。

```java
public class StaticBlockDemo {
    public static List<String> writes = new ArrayList<>();

    static {
        writes.add("沉默王二");
        writes.add("沉默王三");
        writes.add("沉默王四");

        System.out.println("第一块");
    }

    static {
        writes.add("沉默王五");
        writes.add("沉默王六");

        System.out.println("第二块");
    }
}
```



#### 静态内部类

- **定义**：用 `static` 修饰的内部类称为静态内部类。

- 特点：

  - 静态内部类不依赖于外部类的实例，可以直接通过类名访问。
  - 适用于嵌套类中不需要访问外部类成员的场景。

  

  ```
  public class Outer {
      private static String message = "Hello from Outer";
  
      // 静态内部类
      public static class StaticNested {
          public void printMessage() {
              System.out.println(message);
          }
      }
  }
  
  public class Main {
      public static void main(String[] args) {
          // 不需要创建 Outer 实例即可创建 StaticNested 实例
          Outer.StaticNested nested = new Outer.StaticNested();
          nested.printMessage(); // 输出 "Hello from Outer"
      }
  }
  ```

------

### `static` 与非 `static` 的区别

| 特性         | 静态成员（static）             | 实例成员（非 static）            |
| ------------ | ------------------------------ | -------------------------------- |
| **归属**     | 属于类本身                     | 属于类的某个实例                 |
| **访问方式** | 类名.成员（推荐）              | 对象.成员                        |
| **生命周期** | 类加载时创建，类卸载时销毁     | 对象创建时初始化，对象销毁时销毁 |
| **共享性**   | 所有实例共享                   | 每个对象独立                     |
| **访问限制** | 静态方法不能直接访问非静态成员 | 实例方法可以访问静态和非静态成员 |

------

### `static` 的注意事项

1. **静态方法不能访问非静态成员**
    静态方法在调用时可能还没有创建任何对象，因此不能访问依赖于实例的非静态成员。
2. **静态方法不能重写**
    静态方法属于类，不能被子类重写（但可以被隐藏）。
3. **静态变量不能使用 `this` 或 `super`**
    因为 `this` 和 `super` 都指向当前对象，而静态成员属于类，不依赖对象。
4. **静态代码块优先于构造方法执行**
    静态代码块在类加载时执行，构造方法在对象创建时执行。
5. **过度使用 `static` 可能导致设计问题**
    静态成员是全局共享的，过度使用可能导致状态管理混乱，影响代码的可维护性和可测试性。

------

### `static` 的最佳实践

1. **工具类**
    静态方法适合用于工具类（如 `MathUtils`），提供通用功能，无需实例化。
2. **常量定义**
    静态常量适合用于定义程序中不会变化的值，如 `public static final double PI = 3.14159;`。
3. **单例模式**
    使用静态变量实现单例模式，确保类只有一个实例。
4. **资源初始化**
    使用静态代码块加载配置文件、连接数据库等一次性操作。
5. **避免滥用**
    静态变量是全局共享的，滥用可能导致状态污染，影响程序的可维护性。

------

### 总结

| 用途       | 示例                            | 说明                         |
| ---------- | ------------------------------- | ---------------------------- |
| 静态变量   | `public static int count;`      | 所有实例共享，类加载时初始化 |
| 静态方法   | `public static void log();`     | 类级别方法，无需实例化       |
| 静态代码块 | `static { ... }`                | 类加载时执行一次             |
| 静态内部类 | `public static class Nested {}` | 独立于外部类实例             |

## final关键字

在 Java 中，`final` 是一个关键关键字，用于声明**不可变性**（Immutability）的对象，包括类、方法、变量、参数等。它通过限制修改行为，提升代码的安全性、可读性和性能优化。

### 作用

- **不可变性**：被 `final` 修饰的实体一旦初始化后，其值或状态无法被修改。
- **安全性**：防止类被继承、方法被重写、变量被篡改，避免意外修改导致程序错误。
- **性能优化**：JVM 可能对 `final` 变量进行内联优化，或对 `final` 方法调用进行内联，提升运行效率。

### 修饰类

作用该类不能被继承

适用场景

- 设计不需要扩展的类（如工具类、安全敏感类）。
- 确保类的行为和属性不会被子类修改。

```java
final class Utility {
    public static void print() {
        System.out.println("This is a utility class.");
    }
}
```

Java 标准库中的 `String`、`Integer`、`Math` 等类均为 `final` 类，确保其不可变性和安全性。

### 修饰方法

使用final 关键字修饰方法，该方法**不能被子类重写**（Override），保护核心逻辑不被子类修改（如安全校验、关键算法）。防止方法在继承链中被覆盖，确保行为一致性。

```java
class Parent {
    public final void show() {
        System.out.println("Parent's final method.");
    }
}
class Child extends Parent {
    // 下列代码会编译错误：无法重写 final 方法
    // public void show() {}
}
```

> [!NOTE]
>
> - `final` 方法可以被重载（Overload），但不能被覆盖。
> - `private` 方法隐式为 `final`（因为私有方法无法被继承）。

### 修饰变量

- **基本类型变量**：值不可变。
- **引用类型变量**：引用地址不可变，但对象内容可变。

适用场景

- 定义常量（配合 `static` 使用）。
- 在多线程环境中实现线程安全（不可变对象天然线程安全）。

```java
// 基本类型 final 变量
final int MAX = 100;
// MAX = 200; // 编译错误：值不可变

// 引用类型 final 变量
final List<String> list = new ArrayList<>();
list.add("Hello"); // 合法：对象内容可变
// list = new ArrayList<>(); // 编译错误：引用地址不可变

// 静态 final 常量
public static final String APP_NAME = "MyApp";
```

### 修饰方法参数

当适用final 关键字修饰方法体内的参数时，方法体内**不能修改参数值**，防止参数被意外修改，提升代码可读性。

```java
public void process(final int param) {
    // param = 5; // 编译错误：参数不可变
}
```

### 修饰局部变量

局部变量一旦赋值，不能再次修改，如在匿名内部类中访问外部变量（Java 8+ 支持 `effectively final`）。

```
void method() {
    final int localVar = 10;
    // localVar = 20; // 编译错误
}
```

### 注意事项

初始化规则：

- `final` 变量必须在声明时或构造方法中初始化。
- `static final` 变量必须在声明时或静态初始化块中赋值。

不可变对象 ≠ final 变量：

- `final` 保证引用地址不变，但对象内容可能可变（如 `final List` 仍可增删元素）。

final 类中的方法：

- `final` 类中的所有方法默认为 `final`（因为无法被继承覆盖）。

权衡使用：

- 过度使用 `final` 可能导致代码僵化，需根据设计需求合理选择。

## `instanceof `关键字

`instanceof` 是一个**二元操作符**，用于在运行时判断一个对象是否是某个类的实例、某个类的子类实例，或者是否实现了某个接口。它是 Java 类型系统中非常重要的工具，常用于**类型检查**和**安全类型转换**，以避免 `ClassCastException`。

### 基本语法

```java
boolean result = object instanceof Type;
```

- **`object`**：一个对象引用（不能是基本类型）。
- **`Type`**：可以是类名、接口名或数组类型。
- **`result`**：布尔值，表示 `object` 是否是 `Type` 的实例。

```java
Object obj = "Hello";
if (obj instanceof String) {
    System.out.println("obj 是 String 类型");
}
```

### 核心功能

#### 类型检查与安全转换

instanceof` 最常见的用途是判断对象的实际类型，以便进行安全的向下转型（Downcasting），避免 `ClassCastException

```java
List<Object> list = new ArrayList<>();
list.add("Hello");
list.add(123);
list.add(new Double(3.14));

for (Object obj : list) {
    if (obj instanceof String) {
        String str = (String) obj;
        System.out.println("字符串: " + str);
    } else if (obj instanceof Integer) {
        Integer num = (Integer) obj;
        System.out.println("整数: " + num);
    } else if (obj instanceof Number) {
        Number number = (Number) obj;
        System.out.println("数字: " + number);
    }
}
```

#### 多态性下的类型判断

在多态场景中，`instanceof` 可以帮助判断对象的实际类型，从而执行不同的操作。

```java
class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

public class Test {
    public static void main(String[] args) {
        Animal animal = new Dog();
        if (animal instanceof Dog) {
            System.out.println("这是狗");
        } else if (animal instanceof Cat) {
            System.out.println("这是猫");
        }
    }
}
```

####  接口实现的检查

`instanceof` 可以判断对象是否实现了某个接口。

```java
interface Flyable {}
class Bird implements Flyable {}

public class Test {
    public static void main(String[] args) {
        Flyable flyable = new Bird();
        if (flyable instanceof Flyable) {
            System.out.println("Bird 实现了 Flyable 接口");
        }
    }
}
```

### `instanceof` 的行为规则

| **情况**                      | **结果**                                |
| ----------------------------- | --------------------------------------- |
| 对象是 `Type` 或其子类的实例  | `true`                                  |
| 对象实现了 `Type` 接口        | `true`                                  |
| 对象为 `null`                 | `false`                                 |
| 对象与 `Type` 无继承/实现关系 | 编译错误                                |
| `Type` 是基本类型（如 `int`） | 编译错误（`instanceof` 不支持基本类型） |

```java
Integer num = 10;
System.out.println(num instanceof Integer); // true
System.out.println(num instanceof Number);  // true（Integer 是 Number 的子类）
System.out.println(num instanceof String);  // 编译错误（Integer 和 String 无关）

Object obj = null;
System.out.println(obj instanceof Object); // false
```

### 注意事项

**`instanceof` 不能用于基本类型**

```java
int i = 10;
// System.out.println(i instanceof Integer); // 编译错误
```

**`instanceof` 的返回值受继承链影响**

如果对象是 `Type` 的子类实例，`instanceof` 也会返回 `true`。

```java
Number num = Integer.valueOf(10);
System.out.println(num instanceof Integer); // true
System.out.println(num instanceof Number);  // true
System.out.println(num instanceof Object);  // true
```

**`instanceof` 与多态**

`instanceof` 会检查对象的实际类型，而不仅仅是引用类型。

```java
Animal animal = new Dog(); // 父类引用指向子类对象
System.out.println(animal instanceof Dog); // true
System.out.println(animal instanceof Animal); // true
```

**Java 16+ 的模式匹配（Pattern Matching）**

从 Java 16 开始，`instanceof` 支持模式匹配，可以简化代码。

```java
if (obj instanceof String str) {
    System.out.println("字符串长度: " + str.length());
}
```

### **最佳实践**

**避免过度使用 `instanceof`**
 过度使用 `instanceof` 可能表明设计存在问题（如违反开闭原则）。可以通过**多态**或**设计模式**（如策略模式、访问者模式）替代。

**优先使用多态**
 如果需要根据对象类型执行不同操作，优先使用多态，而非 `instanceof`。

**安全使用 `instanceof`**
在向下转型前，始终使用 `instanceof` 检查类型。

##### **正例（多态）**：

```java
// 多态反例
if (animal instanceof Dog) {
    ((Dog) animal).bark();
} else if (animal instanceof Cat) {
    ((Cat) animal).meow();
}

// 多态正例
abstract class Animal {
    abstract void makeSound();
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("汪汪！");
    }
}

class Cat extends Animal {
    void makeSound() {
        System.out.println("喵喵！");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal dog = new Dog();
        dog.makeSound(); // 自动调用 Dog 的 makeSound
    }
}
```

