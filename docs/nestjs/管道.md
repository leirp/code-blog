# 管道

## 管道介绍

管道是具有 `@Injectable()` 装饰器的类。管道应实现 `PipeTransform` 接口。

管道有两个典型的应用场景:

- **转换**：管道将输入数据转换为所需的数据输出(例如，将字符串转换为整数)
- **验证**：对输入数据进行验证，如果验证成功继续传递; 验证失败则抛出异常

 管道 会由控制器进行处理。Nest 会在调用控制器方法之前插入一个管道，管道会先拦截方法的调用参数,进行转换或是验证处理，然后用转换好或是验证好的参数调用原方法。

## 内置管道

## 管道绑定

## 自定义管道

如在管道介绍中说明的是 ，管道应该实现`PipeTransform`接口，该接口中有个 `transform` 方法

```typescript
import { ArgumentMetadata, Injectable, PipeTransform } from '@nestjs/common';
@Injectable()
export class UsersPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    return value;
  }
}
```

```typescript
interface ArgumentMetadata {
  
  type: 'body' | 'query' | 'param' | 'custom'; // 告诉我们参数是一个 body @Body()，query @Query()，param @Param() 还是自定义参数
  metatype?: Type<unknown>;  // 参数的元类型。
  data?: string; //	传递给装饰器的字符串，例如 @Body('string')。如果将括号留空，则为 undefined
}
interface PipeTransform<T = any, R = any> {
    /**
     * Method to implement a custom pipe.  Called with two parameters
     *
     * @param 参数是当前处理的方法参数(在被路由处理程序方法接收之前)
     * @param metadata 是当前处理的方法参数的元数据
     */
    transform(value: T, metadata: ArgumentMetadata): R;
}
```

### 类验证器

使用用类验证器，需要安装两个库

class-validator 库允许使用基于装饰器的验证。 class-validator官方提供的方式还不能直接对一个请求的返回值进行校验，它要求必须要是类的一个对象，所以需要做一些处理，可以将一个json转成指定的类的对象

class-transformer 允许将普通对象转换为类的某个实例，反之亦然。它还允许根据条件序列化/反序列化对象。

在dto 中使用装饰器配置

```typescript
import { IsNotEmpty, Length } from "class-validator";

export class SignInDto {
  @IsNotEmpty({ message: '账号不能为空' })
  @Length(5, 20, { message: '账号长度范围为5~20个字符' })
  username: string;
  @IsNotEmpty({ message: '密码不能为空' })
  @Length(8, 20, { message: '密码长度范围为5~20个字符' })
  password: string;
}
```

使用自定义管道校验：

```typescript
import { ArgumentMetadata, BadRequestException, Injectable, PipeTransform } from "@nestjs/common";
import { validate } from 'class-validator';
import { plainToInstance } from 'class-transformer';
@Injectable()
export class AuthPipe implements PipeTransform {
  async transform(value: any, metadata: ArgumentMetadata) {
    console.log(value, metadata,typeof value);
    // 将普通对象根据构造函数实例化，生成一个构造函数的对象，实际上根据获取的body里的参数，蒋 dto 中的类实例化
    const object = plainToInstance(metadata.metatype, value);
    // 校验dto 的实例化对象
    const errors = await validate(object);
    if (errors.length) {
      console.log(errors);
      throw new BadRequestException(errors);
    }
    return value;
  }
}
```

使用自定义管道

```typescript
@Controller('auth')
export class AuthController {
  constructor(private readonly authService: AuthService) {}
  @Post('login')
  signIn(@Body(AuthPipe) signIn: SignInDto) {
    return this.authService.signIn(signIn.username, signIn.password);
  }
}

```

实际上nestjs 内置了 ValidationPipe 管道实现了如上功能，只需要在需要的地方引用或全局注册

```typescript
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(3000);
}
bootstrap();
```









