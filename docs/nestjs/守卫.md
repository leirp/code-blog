# 守卫

守卫是一个使用 `@Injectable()` 装饰器的类。 守卫应该实现 `CanActivate` 接口。

守卫有一个单独的责任。它们根据运行时出现的某些条件（例如权限，角色，访问控制列表等）来确定给定的请求是否由路由处理程序处理。这通常称为授权。

中间件不知道调用 `next()` 函数后会执行哪个处理程序。另一方面，守卫可以访问 `ExecutionContext` 实例，因此确切地知道接下来要执行什么。它们的设计与异常过滤器、管道和拦截器非常相似，目的是让您在请求/响应周期的正确位置插入处理逻辑，并以声明的方式进行插入。这有助于保持代码的简洁和声明性。

:::tips 守卫在每个中间件之后执行，但在任何拦截器或管道之前执行。

## 授权守卫

一个基本的守卫如下所示：

```typescript
@Injectable()
export class RolesGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    return true;
  }
}
```

## 执行上下文

`canActivate()` 函数接收单个参数 `ExecutionContext` 实例。`ExecutionContext` 继承自 `ArgumentsHost` 。

## 绑定守卫

实现一个 `RolesGuard`

```typescript
import {CanActivate, ExecutionContext, Injectable} from '@nestjs/common'
import { Observable } from 'rxjs'

@Injectable()
export class RolesGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    console.log(context)
    return true
  }
}
```

### 绑定守卫

`@UseGuards()`装饰器设置了一个控制范围的守卫。这个装饰器可以使用单个参数，也可以使用逗号分隔的参数列表。也就是说，你可以传递几个守卫并用逗号分隔它们。

守卫既可以绑定在控制器上，也可以绑定在具体的某一个请求上。可以将守卫附加到此控制器声明的每个处理程序。如果我们希望守卫只应用于单个方法，则需在**方法级别**应用 `@UseGuards()` 装饰器。

```typescript

// 守卫控制器
@Controller('users')
@UseGuards(RolesGuard)
export class UsersController {}

// 路由守卫
@Get()
@UseGuards(AuthGuard,RolesGuard)
findAll() {
  return this.usersService.findAll();
}
```

### 全局绑定

为了设置一个全局守卫，使用Nest应用程序实例的 `useGlobalGuards()` 方法：

```typescript
const app = await NestFactory.create(AppModule);
app.useGlobalGuards(new RolesGuard());
```









