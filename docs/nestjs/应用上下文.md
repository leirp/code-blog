# 执行上下文

设置如下装饰器，在装饰器中打印上下文信息

```
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable()
export class RolesGuard implements CanActivate {
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    console.log(context.getClass());
    return true;
  }
}

```

## ArgumentsHost 类

`ArgumentsHost` 类提供了用于检索传递给处理程序的参数的方法。它允许选择适当的上下文（例如 HTTP、RPC（微服务）或 WebSockets）以从中检索参数。该框架在你可能想要访问它的地方提供了一个 `ArgumentsHost` 的实例，通常作为 `host` 参数引用。

`ArgumentsHost` 只是作为处理程序参数的抽象。对于 HTTP 服务器应用如果使用 `express` ，`host` 对象封装了 Express 的 `[request, response, next]` 数组，其中 `request` 是请求对象，`response` 是响应对象，`next` 是控制应用请求-响应周期的函数。对于 [GraphQL](https://nest.nodejs.cn/graphql/quick-start) 应用，`host` 对象包含 `[root, args, context, info]` 数组。



```typescript
export interface ArgumentsHost {
    /**
     * 返回传递给处理程序的参数数组，在express 中，返回 [req, res, next]，可以使用如下方法结构
     * const [req, res, next] = host.getArgs();
     */
    getArgs<T extends Array<any> = any[]>(): T;
    /**
     * 按索引提取特定参数
     * @param index 
     */
    getArgByIndex<T = any>(index: number): T;
    /**
     * 切换到rpc 上下文
     * 返回带有检索RPC参数的方法的接口
     */
    switchToRpc(): RpcArgumentsHost;
    /**
   	 * 切换到http 上下文
     * 返回带有检索http参数的方法的接口
     */
    switchToHttp(): HttpArgumentsHost;
    /**
     * 切换到WebSockets 上下文
     * @returns interface with methods to retrieve WebSockets arguments
     */
    switchToWs(): WsArgumentsHost;
    /**
     * 确定当前方法当前运行的应用类型,返回http/rpc/graphql
     */
    getType<TContext extends string = ContextType>(): TContext;
   
}
```

## 应用上下文



在构建旨在跨多个应用上下文运行的通用 [guards](https://nest.nodejs.cn/guards)、[filters](https://nest.nodejs.cn/exception-filters) 和 [interceptors](https://nest.nodejs.cn/interceptors) 时，我们需要一种方法来确定我们的方法当前运行的应用类型。使用 `ArgumentsHost` 的 `getType()` 方法执行此操作：

```typescript
if (host.getType() === 'http') {
  // do something that is only important in the context of regular HTTP requests (REST)
} else if (host.getType() === 'rpc') {
  // do something that is only important in the context of Microservice requests
} else if (host.getType<GqlContextType>() === 'graphql') {
  // do something that is only important in the context of GraphQL requests
}
```



#### 主机处理程序参数

要检索传递给处理程序的参数数组，一种方法是使用宿主对象的 `getArgs()` 方法。

```
const [req, res, next] = host.getArgs();
```

使用 `getArgByIndex()` 方法按索引提取特定参数：

```typescript
const request = host.getArgByIndex(0);
const response = host.getArgByIndex(1);
```

通过使用 `host` 对象的实用方法之一切换到适合的应用上下文，从而使代码更加健壮和可重用。

```typescript
/**

 * Switch context to RPC.
 */
switchToRpc(): RpcArgumentsHost;
/**

 * Switch context to HTTP.
 */
switchToHttp(): HttpArgumentsHost;
/**

 * Switch context to WebSockets.
 */
switchToWs(): WsArgumentsHost;
```

其中 `switchToHttp `包含如下方法，其他方法可查看类型声明文件

```typescript
export interface HttpArgumentsHost {
    /**
     * Returns the in-flight `request` object.
     */
    getRequest<T = any>(): T;
    /**
     * Returns the in-flight `response` object.
     */
    getResponse<T = any>(): T;
    getNext<T = any>(): T;
}
```

不建议使用 `getArgs` 或 `getArgByIndex()` ，通过  `switchToHttp `，可以通过下面的方法获取：

```typescript
const ctx = host.switchToHttp();
const request = ctx.getRequest<Request>();
const response = ctx.getResponse<Response>();
```

## 执行上下文

`ExecutionContext` 扩展 `ArgumentsHost`，提供有关当前执行过程的更多详细信息。

nest 在很多地方都提供了  guard（守卫）的 `canActivate()` 方法和 interceptor（拦截器）的 `intercept()` 方法。

```typescript
// 继承了ArgumentsHost
export interface ExecutionContext extends ArgumentsHost {
    /**
     * 返回当前控制的类
     */
    getClass<T = any>(): Type<T>;
    /**
     * 返回当前调用的路由处理程序的引用
     * request pipeline.
     */
    getHandler(): Function;
}
```

`getHandler()` 方法返回对即将被调用的处理程序的引用。`getClass()` 方法返回此特定处理程序所属的 `Controller` 类的类型。例如，在 HTTP 上下文中，如果当前处理的请求是 `POST` 请求，绑定到 `CatsController` 上的 `create()` 方法，则 `getHandler()` 返回对 `create()` 方法的引用，`getClass()` 返回 `CatsController` 类（不是实例）。

```typescript
const methodKey = ctx.getHandler().name; // "create"
const className = ctx.getClass().name; // "CatsController"
```

## 反射和元数据

Nest提供了通过`@SetMetadata()`装饰器将自定义元数据附加在路径处理程序的能力。我们可以在类中获取这些元数据来执行特定决策。

```typescript
@Get()
  @SetMetadata('roles', ['admin'])
  @UseGuards(RolesGuard)
  findAll(@Query() findAllUserDto:FindAllUserDto) {
    console.log(findAllUserDto)
    return this.usersService.findAll();
  }
```

不推荐以上方式，可以使用setMateData 创建自己的装饰器

```typescript
import { SetMetadata } from "@nestjs/common";
export const Roles = (...roles:string[])=>SetMetadata("roles",roles);
```

要访问`role(s)`路径 (自定义元数据),要使用`Reflector`辅助类，它由框架提供，开箱即用，从`@nestjs/core`包导入。`Reflector`可以通过常规方式注入到类:

```typescript
@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private readonly reflector: Reflector) {}
  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    const roles = this.reflector.get('roles',context.getHandler())
    console.log(roles)
    return true
  }
}
```

如过需要在控制器中注入元信息，则在访问时事需要传入该类。

```typescript
const roles = this.reflector.get<string[]>('roles', context.getClass());
```



