# 	组件化

## 类组件

使用类组件，需要先定义一个类，这个类需继承 `React.Component`，且需要定义一个`render` 方法 

```jsx
class Index extends React.Component {
  constructor() {
    super()
    // this.state = {
    //   num: 1
    // }
  }
  // 或者可以直接赋值
  state = {
    num: 1
  }
  render() {
    let { num } = this.state
    return (
      <div>
        <p>计数： { num }</p>
        <button onClick={()=>{
          this.setState({
            num: num+1
          })
        }}>累加</button>
        <button onClick={()=>{
          // 强制更新 不推荐
          this.state.num--
          this.forceUpdate()
        }}>累减</button>
      </div>
    )
  }
}
export default Index
```

### 组件传值

```jsx
import React from "react";
import PropTypes from 'prop-types'
class Index extends React.Component {
  // 默认值
  static defaultProps = {
    num: 1,
    title: 'he'
  }
  // 规则校验
  static propTypes = {
    num: PropTypes.number,
    title: PropTypes.string.isRequired
  }
  constructor(props) {
    // constructor 中可以省略，如果不写，则react会自动执行super 方法
    super(props)
  }

  render() {
    let { title, num } = this.props
    return (
      <>
        <div>hello world</div>
        <div>{ title }</div>
        <div>{ num }</div>
      </>
    )
  }
}
export default Index
```

### 类组件调用初始化过程

​	

1. 创建类实例 
2. 初始化属性与规则校验
3. 初始化状态（state）
4. 触发 `componentWillMount` 周期函数
   1. 此方法是不安全的，不建议使用。
   2. 如果在非严格模式下会有警告，严格模式下会抛出错误
   3. 在非严格模式下，可使用`UNSAFE_componentWillMount`则不会抛出警告或错误
5. 执行render 方法进行渲染
6. 触发 `componentDidMount` 周期函数，页面已经渲染完成，可以获取到真实DOM

## 函数式组件

在16.8 之前，函数式组件是无状态的，在16.8之后推出了hook后，函数式组件可以完成类组件的全部功能

```jsx
function HelloWorld(){
  return (
    <div>hello world</div>
  )
}
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
    <HelloWorld></HelloWorld>
);
```

::: tip
不管是函数式组件还是类组件，组件名称需采用大驼峰命名法
:::

### 函数式组件的创建流程

1. 基于`babel-preset-react-app` 将函数式组件转换为 `React.ceateElement`
2. 执行 `React.createElement` 方法创建`vritualDOM`对象
3. 执行函数，并将虚拟DOM 中的 `props`参数传递给该函数
4. 接收函数执行结果，将虚拟DOM 转为真实DOM

::: tip
函数式组件的每一次更新或渲染，都是把函数重新执行，产生一个全新的私有上下文。
:::

### 组件传值

如上所述，因为执行函数时，将虚拟DOM对象的属性传给了该函数，所以能在子组件中获取所有的props

```jsx
// 父组件
root.render(
  <React.StrictMode>
    <div>
      <App title={title}></App>
    </div>
  </React.StrictMode>
);
// 子组件
export default function App(props) {
  const [num, setNum] = useState(0);
  return (
    <div>
      <h1>hello {props.title}</h1>
      <button onClick={() => {
        setNum(num + 1 );
      }}>点击我</button>
      <h1>{num}</h1>
    </div>
  );
}


```

传递到子组件的 props 中的属性是通过`Object.frozen`方法冻结的，只能获取无法修改，只能读取

```jsx
export default function App(props) {
  console.log(Object.isFrozen(props))   // true 
  return (
    <div></div>
  );
}
```

### 设置默认值

函数本身也是一个对象，可以通过给函数设置添加 `defaultProps`的方式添加默认值

```jsx
function Children(props) {
  const { title,content } = props;
  return (
    <div>
      <h1>{title}</h1>
      <p>{content}</p>
    </div>
  );
}
Children.defaultProps = {
  title: 'hello world'
}
export default Children
```

### 设置规则

为 props 设置规则，需要使用官方插件`prop-types`

```jsx
import PropTyps from 'prop-types'
function Children(props) {
  const { title,content } = props;
  return (
    <div>
      <h1>{title}</h1>
      <p>{content}</p>
    </div>
  );
}
Children.defaultProps = {
  title: 'hello world'
}
Children.propTyps = {
  title: PropTyps.string,
  content: PropTyps.string.isRequired
}
export default Children
```

传递进来的值，首先会进行规则校验，不管校验成功还是失败，最后都会把值给 props，如果不符合设置的规则，控制台会报错。

其他规则可查看网站：[prop-types](https://www.npmjs.com/package/prop-types)

### 插槽

在组件中加入子节点，会将子节点转换为虚拟DOM 并赋值给函数组件的prop.children,可通过插值语法将虚拟Dom进行直接渲染。

```jsx
// 父组件
export default function Index() {
  return (
    <div>
      <h1>index component</h1>
      <Children>
        <h1>标题</h1>
        <p>内容</p>
      </Children>
    </div>
  );
}
// 子组件
function Children(props) {
  const { children } = props;
  return (
    <div>
      {children}
    </div>
  );
}

export default Children
```

需要注意的是，如果没有子节点，children 为 `undefined`,如果为一个子节点，则 children 为子节点本身的虚拟DOM，如果有多个子节点，则为子节点虚拟DOM 组成的数组。

## 组件嵌套

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';

class NavBar extends React.Component {
  render() {
    return (
      <p>this is NavBar</p>
    )
  }
}
class MainContent extends React.Component {
  render() {
    return (
      <p>this is MainContent</p>
    )
  }
}
class Footer extends React.Component {
  render() {
    return (
      <footer>this is footer</footer>
    )
  }
}
class App extends React.Component {
  render() {
    return (
      <div>
        <NavBar></NavBar>
        <MainContent/>
        <Footer/>
      </div>
    )
  }
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
    <App></App>
);	
```



## 组件样式

### 行内样式

要给需要dom 添加行内样式，需要使用表达式传入样式对象的方式来实现：

```jsx
class App extends React.Component {
  render() {
    const style = {
      backgroundColor: 'red'
    }
    return <h1 style={style}>this is React Component</h1>
  }
}
```

行内样式需要写入一个样式文件，而这个样式对象可以放在很多地方，如 `render` 函数中，组件原型中，外链js 文件中等。

### 引入样式文件

```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css'

class App extends React.Component {
  // render() {
  //   return <h1 style={{backgroundColor: 'red'}}>this is React Component</h1>
  // }
  render() {
    const style = {
      backgroundColor: 'red'
    }
    return <h1 style={style} className='active'>this is React Component</h1>
  }
}
```

react 推荐使用行内样式的方式，因为react 觉得每一个组件都是一个独立的整体

但是在大多数情况下，我们还是为这些元素添加类名，但需要注意的是`class` 需要写成`className` ,因为在javascript 中 ` class` 是关键字。