# 侦听器

计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。可以使用 `watch` 在每次响应式属性发生变化时触发一个函数。

```html
<template>
  <input type="text" v-model="question" />
  <span>{{ answer }}</span>
</template>
```

```javascript
// Composition API
import { ref, watch } from 'vue'
const question = ref('')
const answer = ref('')
watch(question, async (newQuestion, oldQuestion) => {
  if (newQuestion.includes('?')) {
    try {
      const res = await fetch('https://yesno.wtf/api')
      answer.value = (await res.json()).answer
    } catch (error) {
      answer.value = 'Error! Could not reach the API. ' + error
    }
  }
})
```

```javascript
// Options API
export default {
  data() {
    return {
      question: '',
      answer: '',
    }
  },
  methods: {
    async getAnswer() {
      this.answer = 'loading...'
      try {
        const res = await fetch('https://yesno.wtf/api')
        this.answer = (await res.json()).answer()
      } catch (error) {
        this.answer = 'Error! Could not reach the API. ' + error
      }
    },
  },
  watch: {
    question(newQuestion, oldQuestion) {
      if (newQuestion.indexOf('?') !== -1) {
        this.getAnswer()
      }
    },
  },
}
```

## 深层侦听器

在 `Options API`中，watch `watch` 默认是浅层的：被侦听的属性，仅在被赋新值时，才会触发回调函数，而嵌套属性的变化不会触发（如给对象的某个属性赋值时）。如果想侦听所有嵌套的变更，你需要深层侦听器.

```javascript
// Options API
export default {
  watch: {
    someObject: {
      handler(newValue, oldValue) {
        // 注意：在嵌套的变更中，
        // 只要没有替换对象本身，
        // 那么这里的 `newValue` 和 `oldValue` 相同
      },
      deep: true
    }
  }
}
```

而在 `Composition API` 中，直接给 watch() 传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发

```javascript
const obj = reactive({ count: 0 })

watch(obj, (newValue, oldValue) => {
  // 在嵌套的属性变更时触发
  // 注意：`newValue` 此处和 `oldValue` 是相等的
  // 因为它们是同一个对象！
})

obj.count++
```

相比之下，一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调，也可以显式地加上 `deep` 选项，强制转成深层侦听器

```javascript
watch(
  () => state.someObject,
  () => {
    // 仅当 state.someObject 被替换时触发
  }
)
// 加入 deep
watch(
  () => state.someObject,
  (newValue, oldValue) => {
    // 注意：`newValue` 此处和 `oldValue` 是相等的
    // *除非* state.someObject 被整个替换了
  },
  { deep: true }
)
```

