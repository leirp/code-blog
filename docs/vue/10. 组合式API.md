# 组合式API

## 1.  什么是组合式API

​	

他是一种一组低侵入式的、函数式的 API，使得我们能够更灵活地「组合」组件的逻辑

## 2. 使用

使用传统的option 配置方法:

```javascript
export default {
  name: 'HelloWorld',
  props: {
    msg: String
  },
  data() {
    return {
      count: 0,
    }
  },
  methods:{
    add(){
      this.count++

    }
  },
  computed:{
    double(){
      return this.count*2
    }
  }
}
```

使用  Composition API

```javascript
let data = reactive({
      // 定义数据
      count:0,
      // 使用 computed 计算属性
      double: computed(()=>data.count*2)
    })
    function add(){
      data.count++
    }
    return {data,add}
```

## 3. 加载顺序与生命周期

### 3.1 加载顺序

```javascript
import {computed, reactive} from 'vue'
export default {
  setup(){
    console.log("setup")
    console.log("this",this)
  },
  beforeCreate() {
    console.log('beforeCreate')
  },
  created(){
    console.log("Created")
  },
  beforeMount() {
    console.log("beforeMount")
  },
  mounted() {
    console.log("Mounted")
  }
}
```

打印结果：

```
setup
this undefined
beforeCreate
Created
beforeMount
Mounted
```

可以看到setup 在beforeCreate 之前，此时vue 实例还未加载，也无法使用this。

### 3.2 生命周期

虽然使用组合式API 的时候也可以在 setup 函数外部使用原始的生命周期函数，但却无法调用setup 中的变量及方法，所以vue 在setup 中也提供了单独的生命周期函数。

下面为组合式API 与普通API 生命周期的对应关系：

```
beforeCreate  -----> setup
created       -----> setup
beforeMount   -----> onBeforeMount
mounted       -----> onMounted
beforeUnmount -----> onBeforeUnount
unmounted     -----> onUnounted
```



## 4. 参数

setup 函数提供了两个参数 props 和 context

- props: 用来接收父组件传递过来的参数，必须使用 props 属性接收后才能在 setup 种的props 种调用出来。
- context : 函数的上下文。其中包含了

props 的使用:

```javascript
import {reactive,computed} from "vue";
export default {
  name: "Child",
  props:{
    hello: {type:String},
    world:{type:String},
  },
  setup(props,context){
    const data = reactive({
      count:0,
    })
    console.log(props);
    console.log(props.hello);
    console.log(props.world);
  }

}
```

context 的使用：

- context.attr : 属性,未通过props 属性接收的数据可以使用context.attrs.值获取
- context.slots : 获取插槽
- context.parent: 父对象
- context.root：根
- context.rmit: 给父组件传值
- context.refs：

```vue
<template>
  <div>
    <slot></slot>
  </div>
</template>

<script>
import {reactive,computed,ref} from "vue";
export default {
  name: "Child",
  props:{
    one:
        {type:String},
    two:{
      type:String,
    }
  },
  setup(props,context){
    console.log(props.one)
    console.log(props.two)
    // 未通过props 属性接收的值可以通过attrs 接收
    console.log(context.attrs.three)
    // 获取插槽
    console.log(context.slots);
    // 获取缺省的插槽
    console.log(context.slots.default());
    // emit 给父组件传值
    context.emit('change','给父组件传值')
    return {

    }
  }
}
</script>
```



## 5. 常用API

### 5.1 ref 的使用：

`ref `函数用来给定的值创建一个响应式数据对象，`ref()`的返回值是一个对象，这个对象上只包含一个 value 的属性

`isRef` 用来判断变量或常量是否时通过 `ref` 来声明

```javascript
import {reactive,ref,isRef} from "vue";
export default {
  name: "Child",

  setup(props,context){
    let num = 1;
    // 直接声明变量时变量为非响应的，当在改变num 的值的时候 html 页面上的num 并不会随之改变。
    let changeNum = ()=>{
      num++;
      console.log(num);
    }
    // 可以通过ref 声明值使其变成响应式，在模板中直接调用如 {{num2}}，在script 种通过 变量.value 调用
    let num2 = ref(2)
    let changeNum2 = (newValue) => {
      num2.value = newValue
      console.log(num2.value)
    }
    let num3 = ref(10)
    // 判断值是否是通过ref 声明的，也就是是否是响应式
    isRef(num3)? num3.value=20:num3=20
    return {
      changeNum,
      num,
      num2,
      changeNum2
    }
  }
}
```

### 5.2 reactive 函数的使用：

`reactive` 函数用来创建一个响应式对象

```vue
<template>
  <p>username:{{user.name}}</p>
  <p>age:{{user.age}}</p>
</template>

<script>
import {reactive,computed,ref} from "vue";
export default {
  name: "Child",
  setup(props,context){
    const user = reactive({
      name:'alex',
      age:'18',
      sex:'男'
       
    })
    // 使用readonly 可以将响应式数据转换为非响应式数据，使用频率较少
    // const user2 = readonly(user)
    return {
      user
    }
  }
}
</script>
```

当使用`reactive`来创建一个响应式对象时，通过 `...` 解构时会变成非响应式的，为了解决这个问题，可以使用 `toRefs`：

```vue
<template>
  <p>username:{{name}}</p>
  <p>age:{{age}}</p>
</template>

<script>
import {reactive,computed,toRefs,readonly} from "vue";
export default {
  name: "Child",
  setup(props,context){
    const user = reactive({
      name:'alex',
      age:'18',
      sex:'男'
    })
    
    return {
      ...toRefs(user)
    }
  }
}
</script>
```

### 5.3 computed 计算属性

```vue
<template>
  <p>firstName:<input type="text" v-model="user.firstName"></p>
  <p>lastName:<input type="text" v-model="user.lastName"></p>
  <p>fullName:{{fullName}}</p>
</template>

<script>
import {reactive,computed,ref,isRef} from "vue";
export default {
  name: "Child",
  setup(props,context){
    const user = reactive({
      firstName:'alex',
      lastName:'lei',
      // 也可以将计算属性直接写在对象中,但不建议这么做
      // fullName: computed(()=>{})
    })

    const fullName = computed(()=>{
      return user.firstName + ' ' + user.lastName
    })
    return {
      user,
      fullName
    }
  }
}
</script>
```

### 5.4 watch 数据监听

```vue
<template>
  <p>a:{{a}}</p>
  <p>b:{{b}}</p>
  <p><button @click="a++">a++</button><button @click="b++">b++</button></p>
  <p>username:<input type="text" v-model="username"></p>
  <p>age: <input type="text" v-model="age"></p>
</template>

<script>
import {reactive,computed,ref,isRef,watch,toRefs} from "vue";
export default {
  name: "Child",
  setup(props,context){
    let a = ref(1)
    let b = ref(2)
    let user = reactive({
      username:'leirp',
      age:18
    })
    // 默认监听
    watch(()=>{
      // 需要执行才能监听
      console.log(a)
    })
    // 监听单个值
    watch(a,(newVal,oldVal)=>{
      console.log(newVal+"++++++++"+oldVal)
    })
    // 监听多个值
    watch([a,b],([newValA,newValB],[oldValA,oldValB],)=>{
      console.log(newValA+ "++++++++" + oldValA)
      console.log(newValB+ "--------" + oldValB)
    })
    // 使用immediate 来控制第一次绑定值时也监听变化
    watch([a,b],([newValA,newValB],[oldValA,oldValB],)=>{
      console.log(newValA+ "++++++++" + oldValA)
      console.log(newValB+ "--------" + oldValB)
    },{immediate:true})
    // 监听对象的值
    watch(()=>user.a,(newValA,oldValA)=>{
      console.log(newValA+ "++++++++" + oldValA)
    })
    // 监听对象的多个值
    watch([()=>user.a,()=>user.b],([newValA,newValB],[oldValA,oldValB])=>{
      console.log(newValA+ "++++++++" + oldValA)
      console.log(newValB+ "--------" + oldValB)
    })
    // watch 也可以直接监听对象
    watch(user,(newUser,oldUser)=>{
      console.log(newUser);
      console.log(oldUser);
    })

    return {
      a,
      b,
      ...toRefs(user)
    }
  }
}
</script>
```

除了 wtach 可以用来监听以外，组合式API 还提供了另外一个函数：`watchEffect`，但使用这个函数实现的功能 `watch` 都能实现

## 6.  provide 与 inject

`provide` 与 `inject` 允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，在起上下游关系成立的时间里始终生效。与选项API 不同的是：他们是响应式的，修改祖先组件后子孙组件也随之改变，且修改子孙组件祖先组件也随之改变，并且可实时刷新到页面上

```vue
// 祖先组件
<template>
  <h1>这是根组件</h1>
  <p><span>{{title}}</span><input type="text" v-model="title"></p>
  <HelloWorld></HelloWorld>
</template>

<script>
import HelloWorld from './components/HelloWorld.vue'
import { ref,provide,reactive} from 'vue'
export default {

  name: 'App',
  components: {
    HelloWorld
  },
  setup(){
    let title = ref('这是一个祖先组件的标题')
    let user = reactive({
      username:'leirp',
      age:18
    })
    provide('title',title)
    provide('user',user)
    return {
      title
    }
  }
}
</script>

// 子孙组件

<template>
  <h3>这是子组件</h3>
  <p>{{title}}</p>
  <p>username:<input type="text" v-model="username"></p>
  <p>age: <input type="text" v-model="age"></p>
</template>

<script>
import {reactive,computed,ref,isRef,watch,toRefs,inject} from "vue";
export default {
  name: "Child",
  setup(props,context){
    let title = inject('title')
    let user = inject('user')
    return {
      title,
      ...toRefs(user)
    }
  }
}
</script>
```



