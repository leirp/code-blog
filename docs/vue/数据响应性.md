# 数据响应性

## 声明响应式状态

### data

选用选项式 API 时，会用 `data` 选项来声明组件的响应式状态。此选项的值应为返回一个对象的函数。Vue 将在创建新组件实例的时候调用此函数，并将函数返回的对象用响应式系统进行包装。此对象的所有顶层属性都会被代理到组件实例 (即方法和生命周期钩子中的 `this`) 上。

```javascript
export default {
  data() {
    return {
      count: 1
    }
  },
  mounted() {
    // `this` 指向当前组件实例
    console.log(this.count) // => 1
    // 数据属性也可以被更改
    this.count = 2
  }
}
```

实例上的属性仅在实例首次创建时被添加，因此需要确保它们都出现在 `data` 函数返回的对象上。若所需的值还未准备好，在必要时也可以使用 `null`、`undefined` 或者其他一些值占位。虽然也可以不在 `data` 上定义，直接向组件实例添加新属性，但这个属性将无法触发响应式更新。

在 Vue 3 中，数据是基于 [JavaScript Proxy（代理）](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy) 实现响应式的。与 Vue 2 不同的是，这里原始的 `newObject` 不会变为响应式：请确保始终通过 `this` 来访问响应式状态。

```javascript
export default {
  data() {
    return {
      someObject: {}
    }
  },
  mounted() {
    const newObject = {}
    this.someObject = newObject
    console.log(newObject === this.someObject) // false
  }
}
```



### reactive

使用 [`reactive()`](https://cn.vuejs.org/api/reactivity-core.html#reactive) 函数创建一个响应式对象或数组

```javascript
import { reactive } from 'vue'
export default {
  setup() {
    const state = reactive({ count: 0 })
    function increment() {
      state.count++
    }
    return {
      state,
      increment
    }
  }
}
```

`reactive()` 的局限性：

- 仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的 原始类型 无效。
- 因为 Vue 的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象的相同引用。这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失，同时这也意味着当我们将响应式对象的属性赋值或解构至本地变量时，或是将该属性传入一个函数时，我们会失去响应性

```javascript
let state = reactive({ count: 0 })
// 上面的引用 ({ count: 0 }) 将不再被追踪（响应性连接已丢失！）
state = reactive({ count: 1 })


const state = reactive({ count: 0 })
// n 是一个局部变量，同 state.count
// 失去响应性连接
let n = state.count
// 不影响原始的 state
n++
// count 也和 state.count 失去了响应性连接
let { count } = state
// 不会影响原始的 state
count++
// 该函数接收一个普通数字，并且
// 将无法跟踪 state.count 的变化
callSomeFunction(state.count)
```



### ref

`reactive()` 的种种限制归根结底是因为 JavaScript 没有可以作用于所有值类型的 “引用” 机制。为此，Vue 提供了一个 [`ref()`](https://cn.vuejs.org/api/reactivity-core.html#ref) 方法来允许我们创建可以使用任何值类型的响应式 **ref**，`ref()` 将传入参数的值包装为一个带 `.value` 属性的 ref 对象：

```javascript
import { ref } from 'vue'
const count = ref(0)

console.log(count) // { value: 0 }
console.log(count.value) // 0
count.value++
console.log(count.value) // 1
```

和响应式对象的属性类似，ref 的 `.value` 属性也是响应式的。同时，当值为对象类型时，会用 `reactive()` 自动转换它的 `.value`。这个对象将通过 [reactive()](https://cn.vuejs.org/api/reactivity-core.html#reactive) 转为具有深层次响应式的对象。这也意味着如果对象中包含了嵌套的 ref，它们将被深层地解包。

一个包含对象类型值的 ref 可以响应式地替换整个对象，ref 被传递给函数或是从一般对象上被解构时，不会丢失响应性

```javascript
const objectRef = ref({ count: 0 })
// 这是响应式的替换
objectRef.value = { count: 1 }

const obj = {
  foo: ref(1),
  bar: ref(2)
}
// 该函数接收一个 ref
// 需要通过 .value 取值
// 但它会保持响应性
callSomeFunction(obj.foo)
// 仍然是响应式的
const { foo, bar } = obj
```

简言之，`ref()` 让我们能创造一种对任意值的 “引用”，并能够在不丢失响应性的前提下传递这些引用。

ref 在模板中的解包：

```vue
<script setup>
import { ref } from 'vue'
const count = ref(0)
function increment() {
  count.value++
}
</script>
<template>
  <button @click="increment">
    {{ count }} <!-- 无需 .value -->
  </button>
</template>
```

仅当 ref 是模板渲染上下文的顶层属性时才适用自动“解包”。 例如， foo 是顶层属性，但 object.foo 不是，此时就会渲染错误。

```
const object = { foo: ref(1) }
{{ object.foo + 1 }}
```

可以通过解构赋值的方式：

```vue
<script setup>
import { ref } from "vue";
const object = { foo: ref(1) }
const { foo } = object
function increment() {
  foo.value++;
}
</script>
<template>
  <button @click="increment">
    {{ foo+2 }}
  </button>
</template>

```

数组和集合类型的 ref 解包：

跟响应式对象不同，当 ref 作为响应式数组或像 `Map` 这种原生集合类型的元素被访问时，不会进行解包。

```javascript
const books = reactive([ref('Vue 3 Guide')])
// 这里需要 .value
console.log(books[0].value)

const map = reactive(new Map([['count', ref(0)]]))
// 这里需要 .value
console.log(map.get('count').value)
```

### readonly

接受一个对象 (不论是响应式还是普通的) 或是一个 [ref](https://cn.vuejs.org/api/reactivity-core.html#ref)，返回一个原值的只读代理。

```javascript
const original = reactive({ count: 0 })
const copy = readonly(original)
watchEffect(() => {
  // 用来做响应性追踪
  console.log(copy.count)
})
// 更改源属性会触发其依赖的侦听器
setTimeout(() => {
  original.count++
}, 5000);


// 更改该只读副本将会失败，并会得到一个警告
setTimeout(() => {
  copy.count++  // warning!
}, 1000);
 
```

### isRef

检查某个值是否为 ref

```javascript
请注意，返回值是一个类型判定 (type predicate)，这意味着 isRef 可以被用作类型守卫
let foo: unknown
if (isRef(foo)) {
  // foo 的类型被收窄为了 Ref<unknown>
  foo.value
} // 
```

::: tip
请注意，返回值是一个类型判定 (type predicate)，这意味着 isRef 可以被用作类型守卫
:::

### isReactive

检查一个对象是否是由 [`reactive()`](https://cn.vuejs.org/api/reactivity-core.html#reactive) 或 [`shallowReactive()`](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive) 创建的代理。

### isReadonly

检查一个对象是否是由 [`readonly()`](https://cn.vuejs.org/api/reactivity-core.html#readonly) 或 [`shallowReadonly()`](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreadonly) 创建的代理。

```javascript
import { reactive, isRef, ref, isReactive, readonly, isReadonly } from "vue";
const original = reactive({ count: 0 });
const data = ref(0);
const copyData = readonly(data);
console.log("---------isRef");
console.log(isRef(original)); //false
console.log(isRef(data)); // true
console.log(isRef(copyData)); //true
console.log("---------isReactive");
console.log(isReactive(original)); //true
console.log(isReactive(data)); //false
console.log(isReactive(copyData)); //false
console.log("isReadonly");
console.log(isReadonly(original));
console.log(isReadonly(data));
console.log(isReadonly(copyData));
```

::: tip
需要注意的是，如果 readOnly 接受的是 ref 或者 reavtive 代理的值，则使用 isRef 或 isReavtive 来检查这个值时返回为 true
:::

### isProxy

检查一个对象是否是由 [`reactive()`](https://cn.vuejs.org/api/reactivity-core.html#reactive)、[`readonly()`](https://cn.vuejs.org/api/reactivity-core.html#readonly)、[`shallowReactive()`](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreactive) 或 [`shallowReadonly()`](https://cn.vuejs.org/api/reactivity-advanced.html#shallowreadonly) 创建的代理。

::: tip
需要注意的是，isProxy 仅限于上述代理方式的检查，如果使用 ref ，则会返回  false
:::

### unref

如果参数是 ref，则返回内部值，否则返回参数本身。这是 `val = isRef(val) ? val.value : val` 计算的一个语法糖。

```javascript
import { ref ,unref} from "vue";
const name = "leirp"
const age = ref(18)
console.log(unref(name))  //leirp
console.log(unref(age))   // 18
```

### toRef

基于响应式对象上的一个属性，创建一个对应的 ref。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。

```javascript
import { reactive,toRef} from "vue";
const person = reactive({
  name: "leirp",
  age: 18
})
const name = toRef(person,"name")
const age = ref(person.age)
name.value = "lx"
// 修改 name 的值,person.name 的值也相应改变
console.log(person.name) lx
person.name = "hell"
// 修改person.name 的值，name 的值也相应改变。
console.log(name.value)   // hell

age.value = 15
// 还是原来的值
console.log(person.age)  // 18
```

::: tip
使用 ref 直接赋值，不会和原始值保持同步，因为ref 接收到的是一个纯数值。
:::

`toRef()` 这个函数在你想把一个 prop 的 ref 传递给一个组合式函数时会很有用：

```javascript

import { toRef } from 'vue'
const props = defineProps(/* ... */)

// 将 `props.foo` 转换为 ref，然后传入
// 一个组合式函数
useSomeFeature(toRef(props, 'foo'))

```

当 `toRef` 与组件 props 结合使用时，关于禁止对 props 做出更改的限制依然有效。尝试将新的值传递给 ref 等效于尝试直接更改 props，这是不允许的。在这种场景下，你可能可以考虑使用带有 `get` 和 `set` 的 [`computed`](https://cn.vuejs.org/api/reactivity-core.html#computed) 替代。

即使源属性当前不存在，`toRef()` 也会返回一个可用的 ref。这让它在处理可选 props 的时候格外实用，相比之下 [`toRefs`](https://cn.vuejs.org/api/reactivity-utilities.html#torefs) 就不会为可选 props 创建对应的 refs。

### toRefs

将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 [`toRef()`](https://cn.vuejs.org/api/reactivity-utilities.html#toref) 创建的。

```javascript
import {reactive, toRef, ref, toRefs} from "vue";
const person = reactive({
  name: "leirp",
  age: 18
})
const personAsToRefs = toRefs(person)
person.name = "lx"
console.log(personAsToRefs.name.value) // lx

personAsToRefs.age.value = 15
console.log(person.age) //15
```

当从组合式函数中返回响应式对象时，`toRefs` 相当有用。使用它，消费者组件可以解构/展开返回的对象而不会失去响应性：

```javascript
function useFeatureX() {
  const state = reactive({
    foo: 1,
    bar: 2
  })
  // ...基于状态的操作逻辑
  // 在返回时都转为 ref
  return toRefs(state)
}
// 可以解构而不会失去响应性
const { foo, bar } = useFeatureX()
```

## DOM 更新时机

当更改响应式状态后，DOM 也会自动更新。然而， DOM 的更新并不是同步的。相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次声明更改，每个组件都只需要更新一次。

若要等待一个状态改变后的 DOM 更新完成，你可以使用 [nextTick()](https://cn.vuejs.org/api/general.html#nexttick) 这个全局 API：

```javascript
// Composition API
import { nextTick } from 'vue'
function increment() {
  state.count++
  nextTick(() => {
    // 访问更新后的 DOM
  })
}
```

```js
// Options API
import { nextTick } from 'vue'
export default {
  methods: {
    increment() {
      this.count++
      nextTick(() => {
        // 访问更新后的 DOM
      })
    }
  }
}
```







