# 计算属性

## 基础示例

模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。比如说，我们有这样一个包含嵌套数组的对象：

```vue
<script setup>
import { reactive } from 'vue'

const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery',
  ]
})
</script>
<template>
  <p>Has published books:</p>
  <span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>
</template>
```

这里的模板看起来有些复杂，并且如果在模板中需要不止一次这样的计算，代码在模板中会计算多遍。因此需要计算属性来描述依赖响应式状态的复杂逻辑。

```html
<template>
  <p>Has published books:</p>
  <span>{{ publishedBooksMessage }}</span>
</template>
```

```javascript

import { reactive , computed } from 'vue'
const author = reactive({
  name: 'John Doe',
  books: [
    'Vue 2 - Advanced Guide',
    'Vue 3 - Basic Guide',
    'Vue 4 - The Mystery',
  ]
})
const publishedBooksMessage = computed(()=>{
  return author.books.length > 0 ? 'Yes' : 'No'
})
```

```javascript
// options API
export default {
  data() {
    return {
      author: {
        name: 'John Doe',
        books: [
          'Vue 2 - Advanced Guide',
          'Vue 3 - Basic Guide',
          'Vue 4 - The Mystery',
        ],
      },
    }
  },
  computed: {
    publishedBooksMessage() {
      return this.author.books.length > 0 ? 'Yes' : 'No'
    },
  },
}
```

## 计算属性缓存 vs 方法

若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于**计算属性值会基于其响应式依赖被缓存**。一个计算属性仅会在其响应式依赖更新时才重新计算。相比之下，方法调用总是会在重渲染发生时再次执行函数。

+ 计算属性是基于它所依赖的数据进行更新，在有在相关依赖的数据发生变化了才会进行更新，而普通的方法每次都会执行
+ 计算属性是有缓存的，只要它所依赖的数据没有发生改变，后面的每一次访问计算属性中的值，都是之前缓存的结果，不会重复执行。

## 可写计算属性

计算属性默认仅能通过计算函数得出结果。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，可以通过同时提供 getter 和 setter 来创建

```html
<template>
  <p>name:</p>
  <span>{{ fullName }}</span>
</template>
<script>
```

```javascript
// Options API
export default {
  data() {
    return {
      firstName: 'lei',
      lastName: 'ruipeng',
    }
  },
  mounted(){
    this.change()
  },
  methods: {
    change() {
      this.fullName = 'liu xiang'
    }
  },
  computed: {
    fullName: {
      get() {
        return this.firstName + ' ' + this.lastName
      },
      set(newName) {
        [this.firstName, this.lastName] = newName.split(' ')
      },
    },
  },
}
```

```javascript
import { ref, computed } from 'vue'
const firstName = ref('lei')
const lastName = ref('ruipeng')
const fullName = computed({
  get() {
    return firstName.value + '' + lastName.value
  },
  set(newValue) {
    ;[firstName.value, lastName.value] = newValue.split(' ')
  },
})
fullName.value = 'liu xiang'
```

## 注意事项

计算属性的计算函数应只做计算而没有任何其他的副作用，不应该在计算函数中做异步请求或者更改 DOM！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此计算函数的职责应该仅为计算和返回该值。

::: tip
副作用：指其他用途
:::

从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。



