# 面向对象

## 基本

- 在面向对象变成中，是通过类来创建对象的，类相当与模具，根据传递的数据来创建对象，并且可以重复的创建对象。
- 在 es6 之前的版本，没有类的概念，不过可以利用构造函数来代替进行创建对象。
- 构造函数跟普通函数没有太大区别，只是调用的时候需要通过 new 关键字来调用。构造函数中的     this 会指向创建出来的对象。并且具备隐式返回操作。
- 定义类一般要求字母大写。所以定义构造函数也要求字母大写

## 对象的创建

###  字面量创建方式

```javascript
var obj = {
    name:'Tom',
    age:18,
    say:function() {
        console.log("My name is " + obj.name)
    }
}
```

### 系统构造函数创建

```javascript
var obj = new Object();
obg.name = "Tom"
obj.age = 18
obj.say = function(){
    console.log("My name is " + obj.name)
}
```

### 自定义构造函数

使用字面量或者系统构造函数只能建立单个对象，如果需要批量建立对象，可以使用自定义构造函数或者工厂模式

```
function People() {
	this.name = name
	this.age = age
}

```

### 工厂模式

工厂模式是一种用来创建对象的设计模式。我们不暴露对象创建的逻辑,而是将逻辑封装在一个函数内,那么这个函数可以成为工厂。

```javascript
function createObject(name) {
	var obj = new Object();
	obj.name = name;
	obj.func = function () {
		console.log('hello wrold');
	}
	return obj
}
var obj = createObject('hello')

```

自定义构造函数和工厂模式的区别

- 工厂模式函数名时小写，自定义构造函数函数名首字母大写
- 工厂模式生成的对象必须 return，自定义构造函数没有返回值，如果人为return的不是对象，直接忽略，如果人为return的是对象，就取代this。
- 工厂模式直接调用函数就可以创建对象，自定义构造函数通过 new 的方式创建对象
- 工厂模式生成的实例对象的__proto__直接指向基类Object的原型
- 构造函数生成的实例对象的__proto__指向他父类的原型，然后父类的原型上的__proto__指向基类Object的原型。

###  实例对象和构造函数

实例对象是通过构造函数（或类）来创建的--创建的过程叫做实例化

判断对象是不是这个这个数据类型

```javascript
// 通过构造器的方式来判断	实例对象.构造器==构造函数名称
obj.__proto.constructor == CreateObject
obj.constructor == CreateObject
// 通过 instanceof 判断
obj instanceof CreateObject
```

## 构造函数

除了使用对象字面量、系统构造函数以及工厂模式以外，还可以通过自定义构造函数的方式创建对象



```javascript
function People() {
	this.name = name
	this.age = age
}
const lei = new People('leirp',18)
```

### new 关键字

当使用new 关键字生成一个对象的时候，会发生一下内容

- 在堆空间创建一个对象

- 对象的[[Prototype]]指向其构造函数的prototype的

- constructor 中this被赋值为这个对象

- 执行 constructor构造器函数 给对象创建属性

### 静态成员和实例成员

实例对象的属性及方法即为实例成员，实例对象是相互独立的，实例对象的实例成员仅在当前对象使用

构造函数的属性及方法即为静态成员，静态方法只能构造函数使用。

```javascript
function People() {
	this.name = name
    // 实例属性
	this.age = age
    // 实例方法
    this.work = function() {console.log('working...')}
}
// 静态属性
People.type = 'people'
// 静态方法
People.say = function() {console.log('我是静态方法');console.log(this === People)}

// 访问静态属性
console.log(People.type)
// 访问静态方法
console.log(People.say)

const lei =new People('lei',19)
// 访问实例属性
console.log(lei.name)
// 访问实例方法
console.log(lei.work())
```

:::tips 在静态方法中，this 指向的是构造函数本身，在实例方法中，this 指向的是生成的对象本身

## 原型

###  构造函数的内存浪费问题

在构造函数中定义方法，在创建对象的时候，每一个实例都会执行构造函数中的逻辑，将属性和方法都挂载到实例上，所以每创建一个实例的时候，都会创建一个函数对象，并且将实例的属性指向该函数对象。虽然数对每一个实例来说，执行的逻辑都是一样的，但是每一个实例中都会保存一个相同的函数对象，这会造成内存浪费。

```javascript
console.log(obj1.func == obj2.func);  //返回 false
```

### 原型介绍

原型可以解决多个对象实例之间资源共用的问题，在 javascript 中，任何对象都有原型， 原型可以理解成是一块共享内存块，在这个内存块中存储着一份数据，所有的实例需要的时候，只需要访问该内存块即可，从而达到共用共享的问题。

- 每个构造函数都有一个prototype 属性，指向另外一个对象，称之为原型对象

- 构造函数通过原型分配的方法是所有对象共享的

- 原型对象可以挂载方法，对象实例化不会多次创建原型上的方法，解约内存

- 原型对象中的this 与构造函数中的this 一样，都指向实例化的对象

  

### 原型的优点

节省内存、数据共享、实现继承

### 原型的案例

```javascript
function CreateObject(name,age) {
	this.name = name;
	this.age = age;
}
//通过构造函数的原型添加一个方法
CreateObject.prototype.func = function () {
	console.log('hello world');
}
var obj1 = new CreateObject('lei',18)
var obj2 = new CreateObject('rui',18)
console.log(obj1.func == obj2.func);  //返回 true

```



### 实例对象的原型

实例对象中也有一个原型对象，通过非标准属性` __proto__ `来访问，他指向的是构造函数的原型对象`prototype` ，所以 原型对象中的constructor 也指向的是构造函数本身。

```javascript

function Student(name, grade) {
  this.name = name;
  this.grade = grade;
}
const stu = new Student('xiaoMing', 6);
console.log(stu.__proto__); // => Student {}
```

```javascript
// __proto__ 是非标准属性，如果要访问一个对象的原型，建议使用 ES6 新增的 Reflect.getPrototypeOf 或者 Object.getPrototypeOf() 方法。
console.log({}.__proto__ === Object.getPrototypeOf({})); // => true
```

对象原型的修改方式（不重要）

```javascript
// 通过 __proto__ 修改
const a = {}
a.__proto__ = {name:'Tom',age:18}

// 通过 Object.setPrototypeOf 修改
Object.setPrototypeOf(a,{name:'Tom',age:18})

// 需要注意的是当设置原型为非对象或者为null 时，设置的原型不生效
obj.__proto__ = 666;
// 非对象和 null 不生效
console.log(obj.__proto__); // => {}

// 当一个对象是不可扩展的，则抛出异常 TypeError
const frozenObj = Object.freeze({});
	// Object.isExtensible(obj) 可以判断 obj 是不是可扩展的
console.log(Object.isExtensible(frozenObj)); // => false
frozenObj.__proto__ = null; // => TypeError: #<Object> is not extensible

// 如果一个对象的 __proto__ 属性被设置为null，这种情况比较复杂
const obj = { name: 'xiaoming' };

obj.__proto__ = null;
// !: 为什么不是 null, 就好像 __proto__ 被 delete 了
console.log(obj.__proto__); // => undefined
// 说明确实将原型设置为 null 了
console.log(Reflect.getPrototypeOf(obj)); // => null

// 再次赋值为 null
obj.__proto__ = null;
// 黑人问号？？？咋不是之前的 undefined 呢？
console.log(obj.__proto__); // => null

obj.__proto__ = { a: 1 };
console.log(obj.__proto__); // => { a: 1 }
// __proto__ 就像一个普通属性一样 obj.xxx = { a: 1 }
// 并没有将原型设置成功
console.log(Reflect.getPrototypeOf(obj)); // => null

Reflect.setPrototypeOf(obj, { b: 2 });
// __proto__ 被设置为 null 后，obj 的 __proto__ 属性和一个普通的属性没有区别
console.log(obj.__proto__); // => { a: 1 }
// 使用 Reflect.setPrototypeOf 是可以设置原型的
console.log(Reflect.getPrototypeOf(obj)); // => { b: 2 }

```

### 构造器 constructor 

每个原型对象`prototype` 中都有一个 constructor  属性，他指向构造函数本身

```javascript
function Apple() {}
const apple = new Apple();
console.log(apple instanceof Apple); 
console.log(Apple.prototype.constructor === Apple); // => true
```

给原型批量添加方法时，如果不重新定义 constructor 属性，则constructor 会指向Object，此时原型对象

```javascript
function Star(name) {
  this.name = name
}
Star.prototype = {
  sing(){console.log('sing')},
  dance(){console.log('dance')}
}
console.log(Star.prototype.constructor) //Object
Star.prototype = {
  constructor: Star.prototype,
  sing(){console.log('sing')},
  dance(){console.log('dance')}
}
```



###  实例对象、原型对象、构造器

![prototype](./images/prototype.jpg)

构造函数中有个属性，`prototype`属性，是构造函数的原型对象，prototype对象相当于特定类型所有实例对象都可以访问的公共容器。

构造函数的原型对象中有个`constructor 属性`，这个属性指向的是原型对象`prototype`所属的构造函数。

```
function Apple() {}
const apple = new Apple();
console.log(Apple.prototype.constructor === Apple)
```

实例对象中有个属性，`__proto__`属性，是实例对象的原型对象，他指向了构造函数的`prototype`原型对象

```javascript
function Apple() {}
const apple = new Apple();
const apple1 = new Apple();
// 实例对象的原型与构造函数的原型相等（指向同一块内容）
console.log(apple.__proto__ === Apple.prototype); // => true
console.log(apple1.__proto__ === apple.__proto__); // => true
```

## 面向对象三大特性

### 继承（不完整）

继承是面向对象中很重要的一个特征，通过继承可以进一步提升代码的封装程度，javascript 中大多数通过原型对象实现继承特性

#### 构造函数继承

使用 call 或 或 apply 实现继承

```javascript
function Person(head,eye) {
  this.head = head
  this.eye = eye
}
Person.prototype.say = funcation(){console.log('hello word')}
function Student(name,head,grade) {
	Person.call(this,name,age)
	this.grade = grade
}

```

:::tips 因为原型上的方法只有在 new 的时候，才会将其指向到对象的原型上，所以这样并不会继承父构造函数原型上的方法

#### 构造函数及原型继承（组合继承）

```javascript
function Person(name,age) {
  this.name = name
  this.age = age
}
Person.prototype.say = funcation(){console.log('hello word')}
function Student(name,age,grade) {
	Person.call(this,name,age)
	this.grade = grade
}
Student.prototype.body = function() {console.log('body')}
//WoMen.prototype = Person.prototype // 如果直接赋值原型，会增加耦合性，应使用 new Person 的方式
//通过 new 的方式改变原型，子构造函数原型上将会出现 父构造函数没用的属性
Student.prototype = new Person()  
Student.prototype.constructor = Student
// 增加方法
Student.prototype.body = function() {console.log('body')}

```

:::tips 子构造器原型中new 完父构造器后，子构造器的原型上的constructor将会指向父构造器，可以通过重新赋值的方式改变 constructor 的指向



### 多态

### 封装

## 原型链

原型链是实例对象与原型之间的链接。

当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。

```javascript
function Person(head,eye) {
  this.head = head
  this.eye = eye
}
Person.prototype.say = funcation(){console.log('hello word')}
function Student(name,head,grade) {
	Person.call(this,name,head)
	this.grade = grade
}
Student.prototype.body = function() {console.log('body')}

const  w = new Student(1,2,100)


console.log(w.__proto__ === Student.prototype)  // true
console.log(Student.prototype.__proto__ === Person.prototype) // true
console.log(Person.prototype.__proto__ === Object.prototype) // true
console.log(Object.prototype.__proto__ === null)   //true
console.log(w.__proto__.__proto__.__proto__.__proto__) //null
```

![PrototypeChain](.\images\PrototypeChain.jpg)

## 面向对象三大特性

## 类

ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。

### 创建类

```javascript
// 自定义构造函数
function Point(x, y) {
  this.x = x;
  this.y = y;
}
 
Point.prototype.toString = function () {
  return '(' + this.x + ', ' + this.y + ')';
};
 
var p = new Point(1, 2);

// ES6 class
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
 // 下面的方法前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。
  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
```

上述代码中使用 class 定义了一个“类”，可以看到里面有一个`constructor()`方法，这就是构造方法，而`this`关键字则代表实例对象。这种 class 写法本质与上面的自定义构造函数一致，完全可以看作构造函数的另一种写法。

```javascript
typeof Point // "function"
// prototype中的constructor属性指向的就是自己所在的原型对象所在的构造函数
Point === Point.prototype.constructor // true
```

### 继承

```javascript
class Person {
  constructor(name,age) {
    this.name = name
    this.age = age
  }
  say(){
    console.log('hello world')
  }
}
class Student extends Person {
  constructor(name,age,grade) {
    super(name,age) // Person.call(this,name,age)
    this.grade = grade 
  }
  printGrade(){
    console.log(this.grade)
  }
  say() {
    super.say() // 直接调用父类中的方法
    console.log('hello student')
  }
}
```

:::tips 要继承父类中的属性，必须调用 super 方法，且必须在构造器中第一个调用。

:::tips 使用 super.method 的方式可以直接调用父类的方法





