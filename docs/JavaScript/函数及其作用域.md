# 函数及其作用域

## 1. 函数的样式

### 1.1. 普通函数

```js
function func1() {
  console.log('hello world');
  return 'hello world'
}
func1(); // hello world
```

### 1.2. 带参数的函数

带参数的函数

```js
function func3(a,b) {
  console.log(a + b);
}
func3(1,2) // 3
```

带默认值参数的函数（如果给有默认值的参数不传递参数，按照默认值计算,且默认值参数写在最后）

```js
function func2(a,b=2) {
  console.log(a + b);
}

func2(1);  // 3
```

当实参的数量小于形参的数量时，多余的形参默认为 `undefined`

```js
function func(a,b,c) {
  console.log(a + b + c);
}
func(1,2);  // NaN
```

当实参的数量大于形参的数量时，多余的实参不计算在内

```js
function func(a,b,c) {
  console.log(a + b + c);
}
func(1,2,3,5);
```

### 1.3.  匿名函数（函数表达式）

```js
const sum = function (a,b) {
  return a+b
};
console.log(sum(1,2));
```

::: tip
与普通函数相比，使用var、const 、let 声明的匿名函数，在加载时，只会预加载变量名，等到调用的时候才会加载函数本身，而普通函数在js 加载时就已预加载
:::

### 1.4. 立即执行函数

```js
(function () {
  console.log('hello 自调用函数2');
})();

(function () {
  console.log('hello 自调用函数1');
}());

```

#### 1.4.1立即执行函数的优势：

防止变量污染：es6 之前 js中没有块级作用域，用来隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。通过定义一个匿名函数，创建了一个新的函数作用域，相当于创建了一个“私有”的命名空间，该命名空间的变量和方法，不会破坏污染全局的命名空间。此时若是想访问全局对象，将全局对象以参数形式传进去即可。

```js
(function (window,undefined) {
  // jQuery code
}(window,undefined));
```

## 2. 作用域

### 2.1. 变量与函数的作用域

使用 var 声明的变量没有块级作用域，函数有作用域。

块级作用域：使用 {} 包裹为块级作用域

### 2.2. 全局作用域

- 直接编写在 script 标签中的 js 代码都是全局作用域

- 全局作用域在页面打开时创建，在页面关闭时销毁

- 在全局作用域中有一个对象：window，window 对象 代表一个浏览器的窗口，他由浏览器创建我们可以直接使用。

- 在全局作用域中使用 var 创建的变量都会作为 window 对象的一个属性保存,在全局作用域中创建的函数都会作为 window 对象的一个方法保存(只针对于浏览器中)

  ```js
  a = 'hello window';
  function func() {
    console.log('hello world');
  }
  
  console.log(window.a);  // hello window
  console.log(window.func()); // hello world
  ```

### 2.3 函数的作用域

- 调用函数时，创建函数作用域，函数执行完毕后，作用域销毁

- 每调用一次函数就会创建新的作用域，他们之间时相互独立的

- 在函数的作用域中，可以访问和改变全局作用域的变量，在全局作用域中，无法访问局部作用域的变量

- 在局部作用域使用 var 声明变量时，会在局部作用域中重新创建一个变量，并不会改变全局作用域的值（两块内存地址），而直接赋值时，默认声明为全局变量

  ```js
  var a = 1;
  function funca() {
      a = 2
  }
  funca()
  alert(a)
  //输出 2 
  
  var b = 3;
  function funcb(){
  	b = 4;
  }
  funcb();
  alert(b)
  输出 4
      
  ```

  

### 2.4. 作用域链

当在局部作用域中访问变量时，他会现在自身作用域中寻找，如果有就直接使用，否则向上级寻找。

### 2.5. if 与 for 的作用域

在 javascript 中 ,在 es6之前因为 if 和 for 都没有块级作用域的概念，所以在很多时候，我们都必须借助与函数的作用域来解决应用外部变量的问题,在es6中，加入了let,let 是有if 和 for 的块级作用域的。

```js
for (let i = 0; i < 10; i++) { 
	setTimeout(function() {
		console.log(i);    //  i 是循环体内局部作用域，不受外界影响。
	}, 0);
}
// 输出结果：0  1  2  3  4  5  6  7  8 9

for (var i = 0; i <10; i++) {  
	setTimeout(function() {  // 同步注册回调函数到 异步的 宏任务队列。
		console.log(i);        // 执行此代码时，同步代码for循环已经执行完成
	}, 0);
}
 // 输出结果:10   共10个 
```

## 3. 箭头函数

### 3.1  箭头函数的基本写法

```js
const ccc = (params)=>{}
```

### 3.2. 参数和返回值

多个参数

```js
const sum = (num1,num2) =>{
	return num1+num2
}

```

一个参数(括号可省略)

```js
const power = num =>{
	return num * num
}

```

代码块中只有一行代码时,可省略大括号和 return

```js
const mul = (num1,num2)=>num1*num2
const demo = () => console.log('hello world')   //console.log() 没有返回值，所以也成立

```

## 4. this 的指向

### 4.1 this 是什么

解析器在调用函数时，每次都会向函数内部传递一个隐含的参数，这个参数就是 this,this 指向的时一个对象，这个对象我们称之为函数的上下文对象。

### 4.2 this 的指向

this即表示调用函数或方法的当前对象

以函数形式调用时，this 永远指向的时 window

以方法的形式调用时，this 就是调用方法的那个对象

```js
// innerDiameter函数中的this是window
// outerDiameter方法中的 this 是 circle 对象
var circle = {
    radius: 10,
    outerDiameter() {
        var innerDiameter = function() {
            console.log(this);
        };
        innerDiameter();
    }
};
circle.outerDiameter(); 
```

当对象中包含另外一个对象时

```js
//obj1对象的o1属性值是obj2对象的地址，而obj2对象的fn属性的值是函数foo的地址；
//函数foo的调用环境是在obj2中的，因此this指向对象obj2;

函数foo的调用环境是在obj2中的，因此this指向对象obj2;

函数foo的调用环境是在obj2中的，因此this指向对象obj2;
function foo() {
    console.log(this.a);
}
var obj2 = {
    a: 2,
    fn: foo
};
var obj1 = {
    a: 1,
    o1: obj2
};
obj1.o1.fn(); // 2

```



### 4.3. 箭头函数的 this 指向

箭头函数没有自己的this值，箭头函数中所使用的this来自于函数作用域链。它会捕获其所在（即定义的位置）上下文的this值， 作为自己的this值

```js
// innerDiameter函数中的this是 circle 对象 因为 innerDiameter 是箭头函数 没有 this,他继承作用域链中 outerDiameter 方法的 this
// outerDiameter方法中的 this 是 circle 对象
var circle = {
    radius: 10,
    outerDiameter() {
        console.log(this);
        var innerDiameter = ()=> {
            console.log(this);
        };
    	innerDiameter();
    }
};
circle.outerDiameter(); 
```



### 4.4 . 不同情况下的  this 指向

#### 4.4.1. 行内样式绑定

```html
<input type="button" value="按钮" onclick="clickFun()">
<script>
    function clickFun(){
        this // 此函数的运行环境在全局window对象下，因此this指向window;
    }
</script>

<input type="button" value="按钮" onclick="this">
<!-- 运行环境在节点对象中，因此this指向本节点对象 -->

```

行内绑定事件的语法是在html节点内，以节点属性的方式绑定，属性名是事件名称前面加'on'，属性的值则是一段可执行的 JS 代码段；而属性值最常见的就是一个函数调用；

当事件触发时，属性值就会作为JS代码被执行，当前运行环境下没有`clickFun`函数，因此浏览器就需要跳出当前运行环境，在整个环境中寻找一个叫`clickFun`的函数并执行这个函数，所以函数内部的this就指向了全局对象window；如果不是一个函数调用，直接在当前节点对象环境下使用this，那么显然this就会指向当前节点对象；

#### 4.4.2. 动态绑定与事件监听

```html
<input type="button" value="按钮" id="btn">
<script>
    var btn = document.getElementById('btn');
    btn.onclick = function(){
        this ;  // this指向本节点对象
    }
</script>
```

因为动态绑定的事件本就是为节点对象的属性(事件名称前面加'on')重新赋值为一个匿名函数，因此函数在执行时就是在节点对象的环境下，this自然就指向了本节点对象

#### 4.4.3 构造函数中的this

```js
function Pro(){
    this.x = '1';
    this.y = function(){};
}
var p = new Pro();
```

#### 4.4.4. window定时器中的this

```js
var obj = {
    fun:function(){
        this ;
    }
}
setInterval(obj.fun,1000);      // this指向window对象
setInterval('obj.fun()',1000);  // this指向obj对象

```

`setInterval()` 是window对象下内置的一个方法，接受两个参数，第一个参数允许是一个函数或者是一段可执行的 JS 代码，第二个参数则是执行前面函数或者代码的时间间隔；

在上面的代码中，`setInterval(obj.fun,1000)` 的第一个参数是`obj`对象的`fun` ，因为 JS 中函数可以被当做值来做引用传递，实际就是将这个函数的地址当做参数传递给了 `setInterval` 方法，换句话说就是 `setInterval` 的第一参数接受了一个函数，那么此时1000毫秒后，函数的运行就已经是在window对象下了，也就是函数的调用者已经变成了window对象，所以其中的this则指向的全局window对象；

而在 `setInterval('obj.fun()',1000)` 中的第一个参数，实际则是传入的一段可执行的 JS 代码；1000毫秒后当 JS 引擎来执行这段代码时，则是通过 `obj` 对象来找到 `fun` 函数并调用执行，那么函数的运行环境依然在 对象 `obj` 内，所以函数内部的this也就指向了 `obj` 对象；

### 4.5. 函数对象的`call()` 与 `apply() `方法

#### 4.5.1. `this 的本质`

函数作为对象提供了`call()`，`apply()` 方法，他们也可以用来调用函数，这两个方法都接受一个对象作为参数，用来指定本次调用时函数中this的指向

函数不同的调用方式

```js
const a = 1
const b = 2
function func(a,b) {
    console.log(a+b)
  }
const obj = {
    name:'hello',
    method:function () {
      console.log(this.name);
    }
}
// 1. 函数的调用
func(a,b)
// 2. 方法的调用
obj.method(a,b)
// 3. 使用 call () 方法调用
func.call(undefined,1,2)
obj.method.call(obj)
```

第三种调用形式，才是正常调用形式：其他两种都是语法糖，可以等价地变为 call 形式。如下所示，this，就是上面代码中的 context。

```text
func.call(context, p1, p2)
```

> 如果的 context 是值 null 或 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）

这样也解释了 严格模式下 `this` 的指向问题。

### 4.5.2. `call()` 与 `apply() `方法  的用途

> `call`方法使用的语法规则
> 函数名称：`call(obj,arg1,arg2...argN)`
> 参数说明：
>
> > `obj`：函数内this要指向的对象,
> > `arg1,arg2...argN` ：参数列表，参数与参数之间使用一个逗号隔开

> `apply`方法使用的语法规则
> 函数名称：`apply(obj,[arg1,arg2...argN])`
> 参数说明：
>
> > `obj`：函数内this要指向的对象,
> > `arg1,arg2...argN` ：参数列表，参数与参数之间使用一个逗号隔开

`call()` 与 `apply()` 方法的用途相同，都接受一个对象作为参数，用来指定本次调用时函数中this的指向，只是传递参数的形式不同。

```js
var lisi = {names:'lisi'};
var zs = {names:'zhangsan'};
function f(age){
    console.log(this.names);
    console.log(age); 
}
f(23);//undefined
//将f函数中的this指向固定到对象zs上；
f.call(zs,32);//zhangsan
```

```js
var lisi = {name:'lisi'}; 
var zs = {name:'zhangsan'}; 
function f(age,sex){
    console.log(this.name+age+sex); 
}
//将f函数中的this指向固定到对象zs上；
f.apply(zs,[23,'nan']);
```

## 5. 高阶函数的使用

### 5.1. ` filter()`  方法

`filter()`用于对数组进行过滤。当每次遍历数组，返回的结果为 true 时，加入新的数组。

```js
let nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
let res = nums.filter((num) => {
    return num > 5;
});
console.log(res);  // [6, 7, 8, 9, 10]
```

### 5.2. `map()`方法

`map()` 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。

`map()` 方法按照原始数组元素顺序依次处理元素

> 语法：`array.map(function(currentValue,index,arr), thisValue)`
>
> 参数
>
> >`currentValue` 必须。当前元素的值
> >
> >`index` 可选。当期元素的索引值
> >
> >`arr` 可选。当期元素属于的数组对象

```js
var array1 = [1,4,9,16];
const map1 = array1.map(x => x *2);
console.log(map1);
打印结果为：[2,8,18,32]
```

### 5.3. `reduce()` 方法

`reduce()` 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。

> 语法：`array.reduce(function(total, currentValue, currentIndex, arr), initialValue)`
>
> 参数：
>
> >`total`    必需。初始值, 或者计算结束后的返回值。
> >
> >`currentValue`    必需。当前元素
> >
> >`currentIndex`    可选。当前元素的索引
> >
> >`arr`    可选。当前元素所属的数组对象。
> >
> >`initialValue`    可选。传递给函数的初始值

```js
var sum = arr.reduce(function (prev, cur) {
    return prev + cur;
},0);
```

## 6. 闭包

### 6.1. 闭包概念

如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包(closure).

### 6.2. 闭包的类型

函数模式的闭包

```js
function f1() {
	let num = 10;
	function f2() {
		console.log(num);
	}
f2()
}
f1()

```

对象模式的闭包

```js
 function f3() {
 	let num = 10;
 	let obj = {
 		age:num;
	}
 	console.log(obj.age)
 }
 f3()				
```

###  6.3 闭包的作用

缓存数据，既是优点也是缺点，没有及时的释放。

延长作用域链：闭包后里面的局部变量的使用作用域链将会被延长。

```js
  function f1() {
      let num = 1;
      num++
      return num
  }
  console.log(f1());  //2
  console.log(f1());  //2
  console.log(f1());  //2
  
  function f2() {
  	let num = 1;
  	return function () {
  		num++;
  		return num
  	}
  }
  let ff = f2();
  console.log(ff());  //2
  console.log(ff());  //3
  console.log(ff());  //4

```

案例：产生三个随机数，每次都是相同的。

```js
function f() {
	let num = parseInt(Math.random()*10+1);
	return function () {
		return num
	}
}
let ff = f();  
console.log(ff());  
console.log(ff());
console.log(ff());
```

## 7. 回调函数

```js
  function openFile(callback) {
    console.log('开始打开文件');
    setTimeout(function () {
      console.log(`·我已经打开文件·`)
      if (typeof callback === 'function') {
        callback()
      }
    },10000)
  }
  function writeFile() {
    console.log(`·我已经写入文件·`)
  }
  
  function func() {
    console.log('我在干其他事');
  }
  openFile(writeFile)
  func()
```



## 8. 递归函数

## Function 构造函数







