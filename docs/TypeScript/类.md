# 类

## 标注类型

```typescript
class Person {
    name:string
    age: number
    constructor(name:string,age:number) {
        this.name = name
        this.age = age
    }
    say(str:string):string {
        return `hello ${str}`
    }
}
```

## 继承

```javascript
class Person {
    name:string
    age: number
    constructor(name:string,age:number) {
        this.name = name
        this.age = age
    }
    say(str:string) {
        return `hello ${str}`
    }
    work() {
        return 'working...'
    }
}
enum Grade {
    one='三年级',
    two="二年级",
    three ="一年级",
}
class Student extends Person{
    grade:Grade
    constructor(name:string,age:number,grade:Grade){
        super(name,age)
        this.grade = grade
    }
    work() {	
        return 'study...'
    }
}

const student = new Student('sun',18,Grade.three)


console.log(student.say('hello'))
console.log(student.work())  
```

`Student` 是一个_派生类_，它派生自 `Person` *基类*，通过 `extends` 关键字。 派生类通常被称作_子类_，基类通常被称作_超类_

派生类包含了一个构造函数,它会执行基类的构造函数。 而且，在构造函数里访问 `this` 的属性之前，我们_一定_要调用 `super()` 。 这个是 `TypeScript `强制执行的一条重要规则。

## 公共，私有与受保护修饰符

### `Public` 修饰符

在 typescript 中，如果没有标注任何修饰符，则成员都默认为 `public`，当然也可以显式的标注出修饰符。

```typescript
class Person {
    public name:string
    public age: number
    public constructor(name:string,age:number) {
        this.name = name
        this.age = age
    }
    public say(str:string) {
        return `hello ${str}`
    }
    public work() {
        return 'working...'
    }
}
```

### `private` 私有修饰符

当成员被标记成 `private` 时，它就不能在声明它的类的外部访问。

```javascript
class Person {
    public name:string
    private age: number
    public constructor(name:string,age:number) {
        this.name = name
        this.age = age
    }
    public say() {
        return `我今年 ${this.age} 了`
    }
    public work() {
        return 'working...'
    }
}
const person =new Person('lei',19)

console.log(person.age) // err 属性“age”为私有属性，只能在类“Person”中访问。
```

`protected` 受保护的修饰符

```javascript
class Person {
    protected name:string
    private age: number
    constructor(name:string,age:number) {
        this.name = name
        this.age = age
    }
    say(str:string) {
        return `hello ${str}`
    }
    work() {
        return 'working...'
    }
}
enum Grade {
    one='三年级',
    two="二年级",
    three ="一年级",
}
class Student extends Person{
    grade:Grade
    constructor(name:string,age:number,grade:Grade){
        super(name,age)
        this.grade = grade
    }
    work() {	
        return `${this.name} 正在学习中`
    }
    say() {
        return `我今年 ${this.age} 了` // err 属性“age”为私有属性，只能在类“Person”中访问。
    }
}

const student = new Student('sun',18,Grade.three)

console.log(student.name)  // err 属性“name”受保护，只能在类“Person”及其子类中访问。
```

:::tip `protected` 修饰符与 `private` 修饰符的行为很相似，但有一点不同， `protected` 成员在派生类中仍然可以访问。

### `readonly` 只读修饰符

```typescript
class Person {
    public name:string
    readonly age: number
    constructor(name:string,age:number) {
        this.name = name
        this.age = age
    }
    say(str:string) {
        return `hello ${str}`
    }
    work() {
        return 'working...'
    }
}
const person = new Person('lei',18)
console.log(person.age)
person.age = 19 // error 无法为“age”赋值，因为它是只读属性.
```

## 静态属性

 类的静态成员，存在于类本身而不是类的实例，使用static 定义。0

```typescript
class Person {
    public name:string
    readonly age: number
    static ancestors = 'monkey'
    constructor(name:string,age:number) {
        this.name = name
        this.age = age
    }
}
console.log(Person.ancestors)
```

