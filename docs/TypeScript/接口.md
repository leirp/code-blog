# 接口

## 定义

TypeScript的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。
在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。

```typescript
// 普通方式进行类型检查
function printLabel(labelledObj: { label: string }) {
  console.log(labelledObj.label);
}

let myObj = { size: 10, label: "Size 10 Object" };
printLabel(myObj);

// 使用接口
interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj);
```

- 对象字面量的某个属性如果定义，则必须要传入

- 对象字面量传入指定的属性的值必须符合定义，如果传入一个已定义的值，但类型不符合会报错

- 对象字面量只能指定已知属性，如果传入一个未定义的值，会报错

- 对象字面量的某个属性如果是可选的，这个属性可以不传入

  
  
  

```typescript
interface IPerson {
    name: string,
    age: number,
    say:(name:string,age:number)=> string
}
const person:IPerson = {
    name: 'lei',
    age: 18,
    say(name:string,age:number)
    {
        return name + age
    }
}
```



## 可选属性	

接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。

带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个`?`符号。

可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。

```typescript
interface SquareConfig {
  width: number,
  color?: string 
}

function createSquare(config: SquareConfig): {color: string; area: number} {
  let newSquare = {color: "white", area: 100};
  if (config.color) {
    newSquare.color = config.color;
  }
  if (config.width) {
    newSquare.area = config.width * config.width;
  }
  return newSquare;
}
let mySquare1 = createSquare({width: 100})  // 无报错 因为 color 为非必要的参数
let mySquare2 = createSquare({color: "black"});  // 报错，因为with 为必要的参数
let mySquare3 = createSquare({width:100:color: 2222})  // 报错，因为 color 传值必须符合其类型
let mySquare4 = createSquare({width: 200,height: 300})  // 报错，对象字面量可以只指定已知属性，并且“height”不在类型“SquareConfig”中
```

## 只读属性

### 对象设置只读

一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 `readonly`来指定只读属性

```typescript
interface Point {
    x: number;
    readonly y: number;
}
let p1: Point = { x: 10, y: 20 };
p1.x = 1 // 无报错
p1.y = 5; // 错误，因为设置了只读属性后，其值只能在定义时修改，后续无法修改
```

### 变量设置只读

TypeScript具有`ReadonlyArray<T>`类型，它与`Array<T>`相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改

```
let a: number[] = [1, 2, 3, 4];
let ro: ReadonlyArray<number> = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
let b = ro; // error!
```

上面代码的最后一行，可以看到就算把整个`ReadonlyArray`赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写

```
let b = ro as number[]
```

## 任意属性

```typescript
interface Person  {
    name: string;
    age: number;
    sex?: string;
    [propName: string] : string| number | undefined
}

const person = {
    name: 'lei',
    age: 18,
    sex: '男',
    say: 'hello world'
}
```

一旦定义了任意属性，那么确定属性和可选属性的的类型必须是任意属性类型的子集。

## 可索引的类型

与使用接口描述函数类型差不多，我们也可以描述那些能够 “通过索引得到” 的类型，比如 `a[10]` 或 `ageMap["daniel"]` 。 可索引类型具有一个_索引签名_，它描述了对象索引的类型，还有相应的索引返回值类型。

```typescript
interface Arr {
    [index:number]: string
}
let arr1:Arr = ['1','2','4'] // 正常
let arr:Arr = [1,2,3,4] // err: 不能将类型“number”分配给类型“string”。
```

## 函数接口

接口能够描述 JavaScript 中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。

为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。

```typescript
interface IFnc {
	//定义函数使用冒号，定义方法使用箭头
    (name: string,age: number) : string
}
```

这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 

```typescript

// 正确
const fn:IFnc = function (name: string,age: number):string {
    return name +age
}
// err: 不能将类型“(name: string, age: string) => string”分配给类型“IFnc”。
const fn1:IFnc = function (name: string,age: string):string { 
    return name +age 
}
```



